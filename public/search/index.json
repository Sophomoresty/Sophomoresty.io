[{"content":"总结 虚拟头结点的序号记为-1, 头结点记为0 tail节点, 一直指向最后1个节点\ntail节点更新的情况\n1.链表0个节点, 头部插入 2.尾部插入 3.任意序号插入, 尾部插入\n易错 addAtIndex 没有处理 index \u0026gt; _size 的情况 添加到尾部的条件错误, 添加到尾部的正确条件是 index == _size deleteAtIndex 1.没更新_size 2.temp指针的空间删除后, 要指向空 3.没有考虑删除尾结点的时候, 要更新_tail 4.没有考虑到删除节点后, 链表为空, 要更新_tail\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 // 定义链表 struct LinkNode { int val; struct LinkNode *next; // 构造函数体 LinkNode() : val(0), next(nullptr) {} LinkNode(int x) : val(x), next(nullptr) {} LinkNode(int x, LinkNode *node) : val(x), next(node) {} }; class MyLinkedList { private: int _size; LinkNode *_dummyHead; LinkNode *_tail; public: MyLinkedList() { _size = 0; _dummyHead = new LinkNode(); _tail = _dummyHead; } int get(int index) { // 判断是否有效 index if (index \u0026lt; 0 || index \u0026gt; _size - 1) { return -1; } LinkNode *cur = _dummyHead; for (int i = 0; i \u0026lt;= index; i++) { cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } void addAtHead(int val) { LinkNode *new_node = new LinkNode(val); new_node-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = new_node; if (_size == 0) { _tail = new_node; } _size++; } void addAtTail(int val) { LinkNode *new_node = new LinkNode(val); _tail-\u0026gt;next = new_node; _tail = new_node; _size++; } void addAtIndex(int index, int val) { // 原始错误 // 1. inde\u0026gt;_size, 没有处理 // 2. 添加到尾部的判断错误, 添加到尾部的添加是index==_size if (index \u0026gt; _size) { return; // index \u0026lt;=0 头部插入 } if (index \u0026lt;= 0) { addAtHead(val); return; } // index = _size-1, 不是尾部插入 , 理解错了, _size-1是尾结点, // index = _size-1 插入实际上是后面的逻辑 if (index == _size) { addAtTail(val); return; } // 0 \u0026lt; index \u0026lt; _size LinkNode *cur = _dummyHead; LinkNode *new_node = new LinkNode(val); // 在index处停止 for (int i = 0; i \u0026lt; index; i++) { cur = cur-\u0026gt;next; } new_node-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = new_node; _size++; } void deleteAtIndex(int index) { // 原始错误 // 1.没更新_size // 2.temp指针的空间删除后, 要指向空 // 3.没有考虑删除到尾结点的时候, _tail的更新 // 4.没有考虑到删除后, 链表为空的情况 if (index \u0026lt; 0 || index \u0026gt; _size - 1) { return; } LinkNode *cur = _dummyHead; for (int i = 0; i \u0026lt; index; i++) { cur = cur-\u0026gt;next; } LinkNode *temp = cur-\u0026gt;next; // 删除的是尾结点 if (temp == _tail) { _tail = cur; } cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete temp; temp = nullptr; _size--; // 删除后如果长度为0 if (_size == 0) { _tail = _dummyHead; } } ~MyLinkedList() { LinkNode *current = _dummyHead; while (current != nullptr) { LinkNode *next = current-\u0026gt;next; // 先保存下一个节点的地址 delete current; // 删除当前节点 current = next; // 移动到下一个节点 } _dummyHead = nullptr; // 删除完后，将头指针置空 _tail = nullptr; // 尾指针也置空 _size = 0; // 尺寸归零 } }; ","date":"2025-05-18T16:41:36+08:00","permalink":"http://localhost:1313/Sophomoresty.io/p/2_%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8_%E7%94%A8size%E5%92%8Ctail_leetcode_707/","title":"2_设计链表_用size和tail_leetcode_707"},{"content":"双指针法1(卡哥思路) 思路和总结 把链表想象为一根绳子, 让绳子右端点对齐\n1.分别遍历A,B两个链表, 得出A,B的长度 2.让长链表的初始指针移动到, 和短链表初始指针对齐\n本次题暴露了自己循环体理解的问题, while和for是等价的\n写好循环体, 一般是通过对应关系去写条件\n对应关系: 本次循环体刚进来的判别的对象 和 对应的变化值\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { // 处理长度为0的情况 if (headA == nullptr || headB == nullptr) { return nullptr; } // 1. 计算链表长度 // 链表的索引从0开始 ListNode *curA, *curB; curA = headA; int len_A, len_B; len_A = 0; len_B = 0; // curA是判别对象 while (curA != nullptr) { curA = curA-\u0026gt;next; len_A++; // 索引 0 -\u0026gt; 长度 1, 正确 } curB = headB; while (curB != nullptr) { curB = curB-\u0026gt;next; len_B++; } // 2. 重置指针 curA = headA; curB = headB; // 3. 将长链表的指针向前移动长度差的步数进行对齐 if (len_A \u0026gt; len_B) { // 从0移动到LA-LB,步数为LA-LB for (int i = 1; i \u0026lt;= (len_A - len_B); i++) { curA = curA-\u0026gt;next; } } if (len_A \u0026lt; len_B) { for (int i = 1; i \u0026lt;= (len_B - len_A); i++) { curB = curB-\u0026gt;next; } } // 现在curA和curB在同一起点, 同时出发 while (curA != nullptr \u0026amp;\u0026amp; curB != nullptr) { if (curA == curB) { return curA; } curA = curA-\u0026gt;next; curB = curB-\u0026gt;next; } return nullptr; } }; 双指针法2 思路和总结 设A独有的长度为a, 和B相同的部分为c; 设B独有长度为b, 和A相同的部分为c; 让A,B链表拼接在一起.\n1 A,B有相同的部分\nurA 从 A 端出发, curB 从 B 端出发, curA 第一次到达相同部分, 移动的距离是a-1 curA 第二次到达相同部分, 移动的距离是a+c-1+b curB 第一次到达相同的部分, 移动的距离是b-1 curB 第二次到达相同的部分, 移动的距离是b+c-1+a 即A,B有相同的部分, 它们一定会移动相同的距离 a+b+c-1, 遇到第一个相等的对象.\n2 A, B没有相同的部分\nA,B会走完全程, 遇到1个相等的对象 nullptr\n总结: 通过让两个指针走的总路程相等(LA+LB)，它们一定会在某个时刻相遇。 而这个相遇点，必然是它们第一次同时到达的、在两条“加长”路径上具有相同相对位置的那个点，也就是相交点（如果存在的话），或者最终的 nullptr（如果不相交的话）。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (!headA || !headB) return nullptr; ListNode *curA, *curB; curA = headA; curB = headB; // 循环退出条件, curA, curB相等 while (curA != curB) { curA = curA == nullptr ? headB : curA-\u0026gt;next; curB = curB == nullptr ? headA : curB-\u0026gt;next; } return curA; } }; 暴力解法 总结 原始错误\n循环嵌套需要初始化curB, 此前没有初始化curB\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { // 0个节点 if (headA == nullptr || headB == nullptr) { return nullptr; } // 暴力解法, 同时遍历A和B, 有个相等时即return ListNode *curA = headA; while (curA != nullptr) { ListNode *curB = headB; // 注意要初始化 while (curB != nullptr) { if (curA == curB) { return curA; } curB = curB-\u0026gt;next; } curA = curA-\u0026gt;next; } return nullptr; } }; ","date":"2025-05-18T16:22:06+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/leetcode_%E9%9D%A2%E8%AF%95%E9%A2%98_0207_%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/","title":"Leetcode_面试题_0207_链表相交"},{"content":"今日BB 前天在配置wsl环境和博客, 昨天只做了区间和开发商问题, 链表的任务全部拖到今天解决了, 花了大半天写完了, 链表还剩链表相交, 今天没时间做了.\n数组收获 开发商题目中最大收获就是在处理行/列分割的时候, 可以用行, 列前缀和处理.\n我最原始的思路是n行m列矩阵, 如果按行分割, 这里约定被分割的行及其前面的都属于前一部分的, 列分割同理, 那行分割的序号可以从1到n-1, 按照矩阵的索引来说, 就是 0 到 n-2.\n比如3行的矩阵\n行分割索引为0, 则分割为[0], [1,2] 行分割索引为1, 则分割为[0,1],[2] 同理列分割的索引可以从0到n-2.\n想到这里的时候, 我是想把分割后的差值的绝对值求出来, 最后一起求最小值, 但是非常繁琐. 看了卡哥的代码豁然开朗.\n1 2 3 4 5 6 7 8 9 10 11 12 int result = INT_MAX; int horizontalCut = 0; for (int i = 0; i \u0026lt; n; i++) { horizontalCut += horizontal[i]; result = min(result, abs(sum - horizontalCut - horizontalCut)); } int verticalCut = 0; for (int j = 0; j \u0026lt; m; j++) { verticalCut += vertical[j]; result = min(result, abs(sum - verticalCut - verticalCut)); } cout \u0026lt;\u0026lt; resu horizontal 和 vertical是前面算出来的矩阵的每行, 毎列的和. sum是矩阵所有元素的和, 这里最开始看不懂的是horizontalCut干嘛的.\n实际上思路和我们前面是一样的, 要求分割后的差值.\ni=0, horizontalCut为第1行的和, 而sum - horizontalCut即为2,3行的和.\n所以i=0时, sum - horizontalCut - horizontalCut即是分割索引为0时, 上下两部分的差值.\n这里的for循环即是把所有分割的可能的差值求出来, 每次都在更新result.\n美中不足的是, i \u0026lt; n不是最精确的范围:\ni = n-1时, horizontal是全部行的和, 这个分割的差值显然是0, 逻辑完善的话, for循环条件应为 i \u0026lt; n - 1.\n链表收获 今天链表比较欠缺的部分是 设计链表 是用不含size属性实现的, 后续要做含size属性的以及双链表.\n之前以为数据结构学过链表, 这里没啥问题. 结果在设计链表的边界处理, 犯了很多错误:\n在链表尾处添加节点, 没有考虑到空节点的情况 两两交换链表中的节点和环形链表中都用了步长为2的指针, 这里最需要注意的就是快指针的边界处理, 很容易操作空指针.\n","date":"2025-05-17T20:31:55+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day_4_%E9%93%BE%E8%A1%A8/","title":"代码随想录_day_4_链表"},{"content":"今日收获 基础题1-6都做完了, 比想象中的简单. 今天学习到最多的就是力扣编号34的, 在排序数组中查找元素的第一个和最后一个位置.\n我原本以为这个和二分查找一样简单, 但发现这个是用二分查找边界. 和卡哥在二分查找的循环变量不同, 思考了2个小时才搞懂, 特此记录下笔记.\n二分查找边界思路 左边界即数组中第1个大于等于target的值, 右边界即数组中第1个大于target的值.\n以二分查找右边界为例, 我们这里采用的循环不变量是[0, left), [right,n).\n这里的n即为数组长度, 采用左闭右开的方式.\n按照循环不变量的思路, 初始化left=0, right=nums.size(). 循环结束条件是left \u0026lt; right.\n精彩的地方来了, 我们如何查找到右边界呢?\n我们只要保证\n[0, left)的数组值严格小于等于target\n[right,n)的值严格大于target 然后不断扩大它们的范围, 直至left=right. 它们相等的值左边小于target, 而这个值本身又大于等于target, 故得出它是第一个大于target的值, 即查找到右边界了, 以上都是建立在target在数组中的.\n如果不在数组中呢?\n1.target在数组的左侧外 2.target在数组的右侧外 3.targe在数组中, 但数组中没有target的这个值\n带入思考, 发现依然能够得出正确的值, 1的右边界索引为0, 2的右边索引为n, 3的右边界索引即为第1个大于target的值的索引.\n左边界的思路同理, 只要保证\n[0, left)的数组值严格小于target\n[right,n)的值严格大于等于target\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left_border = LeftBorder(nums, target); if (left_border == int(nums.size()) || nums[left_border] != target) { return {-1, -1}; } int right_border = RightBoreder(nums, target) - 1; return {left_border, right_border}; } private: int RightBoreder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 缩小区间找第一个大于target的值 int left, right, mid; right = int(nums.size()); left = 0; while (left \u0026lt; right) // [right,n-1)的值严格大于targt // [0, left)的值严格小于等于target // 最后left==right { mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid; } // nums[mid] \u0026lt;= target // 因为left处于开的位置, 已知mid\u0026lt;=target, 故left = mid+1 else { left = mid + 1; // } } return left; } int LeftBorder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left, right, mid; left = 0; right = int(nums.size()); while (left \u0026lt; right) { mid = left + (right - left) / 2; if (nums[mid] \u0026gt;= target) { right = mid; } // nums[mid] \u0026lt; target else { left = mid + 1; } } return left; } }; int main() { vector\u0026lt;int\u0026gt; nums = {5,7,7,8,8,10}; int target = 8; Solution s; vector\u0026lt;int\u0026gt;result = s.searchRange(nums,target); cout \u0026lt;\u0026lt;\u0026#34;Result for \u0026#34;\u0026lt;\u0026lt; target \u0026lt;\u0026lt; \u0026#34;: [\u0026#34; \u0026lt;\u0026lt; result[0] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; result[1] \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-16T15:39:59+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day_1_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%BE%B9%E7%95%8C/","title":"代码随想录_day_1_二分查找边界"},{"content":"简介 这是 粗体 文本，这是 斜体 文本。\n访问 Hugo 网站！\n测试\n","date":"2025-05-16T10:40:00+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/my-first-post/","title":"My First Post"}]