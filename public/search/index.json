[{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n24_二叉搜索树的最小绝对差_leetcode_530 本题要求找出二叉搜索树 (BST) 中任意两个节点值之间的最小绝对差。\n1. 问题核心：BST 的有序性 解决这道题的关键在于利用 BST 的核心特性：\nBST 的中序遍历结果是一个严格递增的有序序列。 在有序序列中，最小的差值必然发生在相邻元素之间。 因此，我们的任务就变成了：对 BST 进行中序遍历，并在遍历过程中比较相邻节点的值，找出最小差值。\n2. 解法：递归中序遍历 + 辅助变量 最经典且高效的方法是采用递归中序遍历。为了在递归调用中“记住”前一个访问的节点，我们需要一个辅助变量。\n核心思路 执行标准的中序遍历（左子树 -\u0026gt; 根节点 -\u0026gt; 右子树）。当访问到每个节点（“根”部分）时，将其值与前一个已经访问过的节点的值进行比较，并更新最小差值。\n实现细节与重要考点 辅助变量： 使用类成员变量 TreeNode* pre 来存储中序遍历中当前节点的前一个节点的指针。 使用类成员变量 int res_min 来存储迄今为止找到的最小绝对差，并初始化为 INT_MAX。 函数设计： 通常会有一个 void 类型的辅助递归函数（例如 getMinimumDifference_help），它负责执行中序遍历并更新 pre 和 res_min 这两个成员变量。 公共接口函数 getMinimumDifference(TreeNode* root) 则负责初始化 pre 和 res_min，调用辅助函数，并最终返回 res_min。 重置关键： 最重要的一点：由于 pre 和 res_min 是类成员变量，它们会保留上一个测试用例的状态。因此，在公共接口函数 getMinimumDifference 的开头，必须显式地将 pre 重置为 nullptr，将 res_min 重置为 INT_MAX。这是确保每次函数调用独立且结果正确的核心。 计算与更新： 在 getMinimumDifference_help 函数中，当中序遍历访问到当前节点 root 时： 首先递归处理左子树。 然后，检查 pre 是否为 nullptr。如果 pre 不为空（说明 root 不是中序遍历的第一个节点），就计算 std::abs(pre-\u0026gt;val - root-\u0026gt;val)。 使用 std::min(res_min, current_diff) 或一个 if 语句来更新 res_min。 最后，将 pre 更新为当前节点 root，为处理下一个节点做准备。 接着递归处理右子树。 最终代码逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;algorithm\u0026gt; // For std::min #include \u0026lt;climits\u0026gt; // For INT_MAX #include \u0026lt;cmath\u0026gt; // For std::abs // TreeNode 结构体定义 (此处省略，假设已提供) class Solution { private: int res_min_member; // 类成员变量，用于保存最小绝对差 TreeNode *pre_member; // 类成员变量，用于保存中序遍历的前一个节点 // 辅助递归函数：执行中序遍历并计算最小绝对差 void getMinimumDifference_help(TreeNode *root) { if (root == nullptr) { return; // 终止条件：空节点，停止递归 } // 1. 递归左子树 (中序遍历的 \u0026#34;左\u0026#34; 部分) getMinimumDifference_help(root-\u0026gt;left); // 2. 处理当前节点 (中序遍历的 \u0026#34;根\u0026#34; 部分) if (pre_member != nullptr) { // 只有当 pre_member 不为空时，才能计算差值 int current_diff = std::abs(pre_member-\u0026gt;val - root-\u0026gt;val); res_min_member = std::min(res_min_member, current_diff); // 更新最小差值 } pre_member = root; // 更新前一个节点为当前节点 // 3. 递归右子树 (中序遍历的 \u0026#34;右\u0026#34; 部分) getMinimumDifference_help(root-\u0026gt;right); } public: // 主入口函数 int getMinimumDifference(TreeNode *root) { // 每次调用公共接口时，重置成员变量，确保计算独立性 res_min_member = INT_MAX; pre_member = nullptr; getMinimumDifference_help(root); // 调用辅助递归函数 return res_min_member; // 返回最终结果 } }; 4. 复杂度 时间复杂度：$O(N)$。每个节点被访问一次。 空间复杂度：$O(H)$，其中 $H$ 是树的高度。主要来自递归栈的深度。最坏情况下 (倾斜树) $O(N)$。 25_二叉搜索树中的众数_leetcode_501 1. 问题描述与挑战 本题要求找出二叉搜索树 (BST) 中出现频率最高的元素（即众数）。BST 中的元素值可能存在重复。\n挑战：如何高效地统计频率，并找出众数，同时尽量优化空间复杂度。\n2. 问题核心：BST 中序遍历的有序性 解决这道题的关键在于利用 BST 的中序遍历特性：\nBST 的中序遍历结果是一个有序序列。 在有序序列中，相同的元素值必然是连续出现的。 这个特性使得我们无需使用额外的哈希表（unordered_map）来统计所有频率，从而实现 $O(1)$ 的额外空间复杂度（不计算递归栈空间和结果存储空间）。\n3. 解法：一次中序遍历 + 精妙的状态管理 (最优解) 这是本题最推荐且最具挑战性的解法，它在一次中序遍历中完成频率统计和众数收集。\n核心思路 执行标准的中序遍历（左子树 -\u0026gt; 根节点 -\u0026gt; 右子树）。在遍历过程中，维护三个状态变量：\npre：指向中序遍历中当前节点前一个访问过的节点。 count：记录当前节点值连续出现的次数。 max_count：记录迄今为止遇到的最大频率。 实现细节与重要考点 状态变量：\nTreeNode *pre;：保存前一个访问的节点，用于比较当前节点值。 int count;：记录当前数字的连续出现次数。 int max_count;：记录历史最高频率。 std::vector\u0026lt;int\u0026gt; res_vec;：存储最终的众数结果（因为可能不止一个众数）。 函数设计：\nvoid inorder_traversal(TreeNode *root)：一个 void 类型的辅助递归函数，负责执行中序遍历并动态更新上述状态变量。 std::vector\u0026lt;int\u0026gt; findMode(TreeNode *root)：公共接口函数，负责初始化所有成员变量，调用辅助函数，并最终返回 res_vec。 状态更新逻辑 (中序遍历核心)：\n当遍历到当前节点 root 时： 更新 count： 如果 pre 为空（即 root 是中序遍历的第一个节点），count = 1。 如果 root-\u0026gt;val == pre-\u0026gt;val，count++。 如果 root-\u0026gt;val != pre-\u0026gt;val，count = 1（重置计数）。 更新 max_count 和 res_vec： 如果 count == max_count：说明当前值也是众数，将其加入 res_vec。 如果 count \u0026gt; max_count：发现新的最高频率，更新 max_count，清空 res_vec，然后将当前值加入 res_vec。 如果 count \u0026lt; max_count：不做任何操作。 更新 pre：pre = root; 为下一次比较做准备。 成员变量重置：\n最重要的一点：由于 pre、count、max_count 和 res_vec 是类成员变量，它们会保留上一个测试用例的状态。因此，在公共接口函数 findMode 的开头，必须显式地重置它们（pre = nullptr; count = 0; max_count = 0; res_vec.clear();），以确保每次函数调用独立且结果正确。 最终代码逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 # include \u0026lt;climits\u0026gt; // 包含 INT_MIN (用于 max_count 的初始化) # include \u0026lt;vector\u0026gt; using namespace std; // TreeNode 结构体定义 (通常 LeetCode 环境会提供) struct TreeNode { int val; TreeNode *left; TreeNode*right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode*right) : val(x), left(left), right(right) {} }; class Solution { private: TreeNode *pre; // 指向前一个遍历到的节点 (中序遍历顺序) int count; // 当前节点值连续出现的次数 int max_count; // 遍历过程中遇到的最大频率 std::vector\u0026lt;int\u0026gt; res_vec; // 存储最终的众数 (可能不止一个) public: // 辅助函数：执行中序遍历并动态更新频率和众数 // 返回值：void (通过成员变量修改外部状态) void inorder_traversal(TreeNode *root) { // 1. 终止条件 / 基本情况 if (root == nullptr) { return; } // 2. 递归左子树 (中序遍历的 \u0026#34;左\u0026#34; 部分) inorder_traversal(root-\u0026gt;left); // 3. 处理当前节点 (中序遍历的 \u0026#34;根\u0026#34; 部分) - 核心逻辑 // 步骤 A: 更新当前节点值的连续出现次数 (count) if (pre == nullptr) { // 如果 pre 为空，说明当前是中序遍历的第一个节点 count = 1; } else if (pre-\u0026gt;val == root-\u0026gt;val) { // 如果当前节点值与前一个节点值相同 count++; // 连续计数递增 } else { // 如果当前节点值与前一个节点值不同 count = 1; // 重置连续计数为 1 } pre = root; // 更新 pre 指针为当前节点 (为下一个节点的比较做准备) // 步骤 B: 根据 count 更新 max_count 和 res_vec (收集众数) if (count == max_count) { // 如果当前连续计数等于已知的最大频率，说明找到了一个等频率的众数 res_vec.push_back(root-\u0026gt;val); } else if (count \u0026gt; max_count) { // 如果当前连续计数大于已知的最大频率，说明找到了新的最大频率 max_count = count; // 更新最大频率 res_vec.clear(); // 清空之前存储的众数 (因为它们频率不够了) res_vec.push_back(root-\u0026gt;val); // 将当前节点值作为新的众数加入 } // else if (count \u0026lt; max_count): 这种情况不需要任何操作，因为当前频率不够高 // 4. 递归右子树 (中序遍历的 \u0026#34;右\u0026#34; 部分) inorder_traversal(root-\u0026gt;right); } // 主入口函数 vector\u0026lt;int\u0026gt; findMode(TreeNode *root) { // **关键修正**：每次调用公共接口时，重置成员变量， // 避免多个测试用例之间互相影响，确保每次计算都是独立的。 pre = nullptr; // 重置 pre 指针 count = 0; // 重置连续计数 (实际在第一个节点会被设为1，这里设0或任意值都可以) max_count = 0; // 重置最大频率 (初始为0，确保任何正频率都能成为最大) res_vec.clear(); // 清空结果数组 // 调用辅助递归函数开始遍历和计算 inorder_traversal(root); // 返回最终收集到的众数列表 return res_vec; } }; 5. 复杂度 时间复杂度：$O(N)$。中序遍历会访问树中的每个节点一次。 空间复杂度：$O(H)$ (递归栈的深度，最坏 $O(N)$) + $O(K)$ (结果数组 res_vec，K 为众数个数，最坏 $O(N)$)。额外空间复杂度为 $O(1)$ (不计算递归栈和结果存储空间)。 26_二叉树的最近公共祖先_leetcode_236 1. 问题描述与挑战 给定一个二叉树的根节点 root，以及树中的两个不同节点 p 和 q，找出它们的最近公共祖先 (LCA)。最近公共祖先的定义是：“对于有根树 T 的两个节点 p、q，最近公共祖先 LCA(T, p, q) 是指一个最低的节点 z，使得 z 既是 p 的祖先，又是 q 的祖先（我们允许一个节点是它自己的祖先）。”\n挑战：LCA 问题的递归模式与传统二叉树遍历（前、中、后、层序）或简单递归（如计算高度、路径和）不同，它需要更复杂的自底向上信息汇报和分叉点识别。\n2. 递归设计方法论在 LCA 中的应用 LCA 问题是理解递归函数“承诺”模型和自底向上信息回溯的经典案例。\n2.1 核心思想：函数就是黑箱 — 相信与承诺 所有递归设计的起点。我们将 TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 这个函数视为一个能完成特定任务的“黑箱”。\n函数签名：TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 函数承诺 (核心！)：当这个函数被调用在某个子树的根节点 root 上时，它承诺会返回： 如果 p 和 q 都存在于 以 root 为根的这棵子树中： 返回它们的最近公共祖先 (LCA) 节点。 如果 p 和 q 只有一个存在于 以 root 为根的这棵子树中： 返回那个存在的节点 (p 或 q)。 如果 p 和 q 都不存在于 以 root 为根的这棵子树中： 返回 nullptr。 2.2 基本情况 (Base Case) — 递归的终点 root == nullptr：空节点无法包含 p 或 q。 返回：nullptr (兑现承诺：什么都没找到)。 root == p || root == q：当前节点就是 p 或 q 中的一个。 返回：root (兑现承诺：我找到了其中一个目标节点，就返回我。如果另一个目标节点在我的子树里，那我就是 LCA；否则，我就是那个唯一找到的节点)。 2.3 递归关系 (Recursive Relation) — 分解与组合 这是“相信”的力量。假设子问题 (root-\u0026gt;left 和 root-\u0026gt;right) 的 lowestCommonAncestor 调用已经兑现了它们的“承诺”，返回了正确结果 (left_res 和 right_res)。现在，root 需要根据这些“汇报”，决定自己向上一层汇报什么。\n场景 1：left_res 和 right_res 都非空 (left_res != nullptr \u0026amp;\u0026amp; right_res != nullptr)\n含义：左子树汇报找到了一个目标（或其 LCA），右子树也汇报找到了另一个目标（或其 LCA）。这说明 p 和 q 分别位于 root 的左右子树中。 结论：当前 root 就是 p 和 q 的 LCA。 返回：root (兑现承诺：返回 LCA)。 场景 2：left_res 为空，right_res 非空 (left_res == nullptr \u0026amp;\u0026amp; right_res != nullptr)\n含义：左子树什么都没找到，所有目标节点（p 和 q，或其中一个）都存在于 root 的右子树中。 结论：LCA 必然在右子树中，或者 right_res 本身就是 p 或 q。 返回：right_res (兑现承诺：返回那个存在的目标节点或子树中的 LCA)。 场景 3：left_res 非空，right_res 为空 (left_res != nullptr \u0026amp;\u0026amp; right_res == nullptr)\n含义：右子树什么都没找到，所有目标节点（p 和 q，或其中一个）都存在于 root 的左子树中。 结论：LCA 必然在左子树中，或者 left_res 本身就是 p 或 q。 返回：left_res (兑现承诺：返回那个存在的目标节点或子树中的 LCA)。 场景 4：left_res 和 right_res 都为空 (left_res == nullptr \u0026amp;\u0026amp; right_res == nullptr)\n含义：左右子树都什么都没找到。 结论：p 和 q 都不存在于以 root 为根的这棵子树中。 返回：nullptr (兑现承诺：什么都没找到)。 2.4 信息流向：自底向上汇报结果 LCA 的递归本质是自底向上的信息传递。p 和 q 就像在树中发出信号的灯塔。这些信号沿着调用栈一层层向上回溯，直到：\n信号汇聚点：第一个同时收到来自左右子树信号的祖先节点，它就“捕获”了这两个信号，并识别出自己就是 LCA。 信号传递者：如果一个节点只收到一个信号，它就继续把这个信号往上传。 3. 最终代码逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 struct TreeNode { int val; TreeNode*left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; class Solution { public: // 1.明确签名与承诺: // 参数是当前树的节点, p,q两个目标节点 // 承诺, 我感觉要回答承诺, 在一开始我很难直接给出, 我需要写出整体的函数框架, 才能给出承诺 // 这里的承诺不是单一的, 思考也不能从根节点出发, 首先我们是自底向上的, 所以要代入基础情况和中间节点思考, 最后再到根节点 // 从基础情况来看, root是空节点直接返回空节点; root是p或则q, 返回root, 表明我们找到了p或则q // 后续就是遵循自底向上, 也就是后序遍历, 我们拿到左右子树返回的结果, 噢, 不对由于后续的内容我还没思考, 我也不知道它返回什么结果. // 所以承诺必须得一开始思考出来, 在这里写的时候把函数当成黑箱, 用承诺去理解. // 所以承诺是: // 1) 如果有p或则q, 我返回给你 // 2) 如果有p和q的最近的公共祖先, 我返回给你 // 3) 如果没有p和q, 我返回给你空 // 2.基本情况 // 1) root是空节点 // 2) root是p或则q // 3.假设子问题已经解决, 我现在需要综合左右子树返回的信息, 继续向上传递 // 如果左右均不为空, 意味着root是最近的公共祖先 // 如果左右其中一个为空, 我继续向上传递不为空 // 如果左右均为空, 我传递为空 // 4.信息流向, 自下而上汇报结果 // 5.剪枝/优化, 优化不了, 我需要逐一从下往上汇报给根节点, 不能提前停止 TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) { // 2.基本情况 if (root == nullptr) { return root; } if (root == p || root == q) { return root; } // 3.递归关系 TreeNode *left_res = lowestCommonAncestor(root-\u0026gt;left, p, q); TreeNode *right_res = lowestCommonAncestor(root-\u0026gt;right, p, q); // 拿到左右子树的结果, root要根据现有的信息再向上汇报 if (left_res != nullptr \u0026amp;\u0026amp; right_res != nullptr) { return root; } else if (left_res != nullptr) { return left_res; } else { return right_res; } } }; 4. 复杂度分析 时间复杂度：$O(N)$。在最坏情况下，需要遍历树中的所有节点。每个节点最多被访问一次。 空间复杂度：$O(H)$，其中 $H$ 是树的高度。这主要来自递归栈的深度。在最坏情况下（树倾斜），$H$ 可以是 $N$，所以空间复杂度为 $O(N)$。 ","date":"2025-06-05T14:38:36+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day18/","title":"代码随想录_day18"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n19_单调栈做法_最大二叉树_leetcode_654 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: TreeNode *constructMaximumBinaryTree(std::vector\u0026lt;int\u0026gt; \u0026amp;nums) { /*单调递减栈能做最大二叉树的原因: 单调栈擅长解决“寻找左右第一个更大/更小元素”问题高度 而对于本题数组中的任意元素 X (nums[i])： X 的左孩子：是 X 左边子数组中作为根的那个元素. 准确说, 是 X 左侧、且在 X 左边第一个比 X 大的元素的右侧范围内的最大值. X 的右孩子：是 X 右边子数组中作为根的那个元素. 准确说, 是 X 右侧、且在 X 右边第一个比 X 大的元素的左侧范围内的最大值. X 的父节点：是 X 左边第一个比它大的元素 和 X 右边第一个比它大的元素 中值较小的那一个. 如果它两边都没有比它大的, 那它就是整个树的根. 恰好符合单调栈的解决问题的特征 */ std::stack\u0026lt;TreeNode *\u0026gt; st; // 存储 TreeNode* 的单调递减栈 // 遍历输入数组中的每个数字 for (int i = 0; i \u0026lt; nums.size(); i++) { // 1. 为当前数字创建一个 TreeNode 节点 TreeNode *cur = new TreeNode(nums[i]); // 2. “收编”阶段 (构建树的左子树) ：处理栈内比 cur 小的元素 // 最后一次循环中的栈顶节点 p 满足: // 是 cur 右侧, 且在 cur 左边第一个比 cur 大的元素的右侧范围内的最大值. // 总结: 循环中最后一次的栈顶节点 p 是 cur 的 左孩子 while (!st.empty() \u0026amp;\u0026amp; st.top()-\u0026gt;val \u0026lt; cur-\u0026gt;val) { TreeNode *p = st.top(); // 获取栈顶节点 p st.pop(); // 将 p 弹出栈 cur-\u0026gt;left = p; } // 3. “被收编”阶段 (构建树的右子树) ： 如果栈非空, 意味着栈内有元素, 且大于cur // 此时的栈顶节点 t 即是 cur左边第一个比它大的元素, cur也是t临近的右侧子数组中的根节点 // 总结: 栈顶是cur的爸爸, cur是栈顶的右孩子 if (!st.empty()) { TreeNode *t = st.top(); // 获取栈顶节点 t t-\u0026gt;right = cur; // 将 cur 设置为 t 的右孩子 } // 4. 入栈 st.push(cur); } // 5. 获取根节点 // 树构建完毕, 栈非空, 栈底即是我们的根节点 // 为什么非空? 为什么栈底是我们的根节点? // 我们维护的栈是单调递减栈, 维护体现在while循环中的pop中. // 根节点一旦入栈后, 将不会再遇到比它更大的元素（因为它已经是最大), // 因此它将永远不会被弹出, 并最终留在栈中, 沉到栈底. // 所以栈一定非空 且 栈底元素即为树的根节点. TreeNode *root = nullptr; // 初始化 root 为 nullptr if (!st.empty()) { root = st.top(); // 初始时 root 指向栈顶（可能是根, 也可能是根的右子孙） while (st.size() \u0026gt; 1) { // 循环弹出, 直到栈中只剩一个元素（根节点） st.pop(); root = st.top(); // 更新 root 为新的栈顶（向栈底移动） } } return root; // 返回最终的根节点 } }; 19_递归做法_最大二叉树_leetcode_654 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { private: // 采取左闭右开 TreeNode *constructMaximumBinaryTree_help(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int start, int end) { // 1.终止条件, 数组为空 if (start \u0026gt;= end) { return nullptr; } // 2.寻找最大值及其索引, 这里时间复杂度有点高, 特别是递归多次的话, 能否优化 int max = nums[start]; int max_index = start; for (int i = start; i \u0026lt; end; i++) { if (nums[i] \u0026gt; max) { max = nums[i]; max_index = i; } } // 3.创建节点 TreeNode *node = new TreeNode(max); // 4.分割数组 // 1) 左子树 int start_left = start; int end_left = max_index; // 2) 右子树 int start_right = max_index + 1; int end_right = end; // 5.递归处理 node-\u0026gt;left = constructMaximumBinaryTree_help(nums, start_left, end_left); node-\u0026gt;right = constructMaximumBinaryTree_help(nums, start_right, end_right); return node; } public: TreeNode *constructMaximumBinaryTree(vector\u0026lt;int\u0026gt; \u0026amp;nums) { return constructMaximumBinaryTree_help(nums, 0, nums.size()); } }; 21_合并二叉树_leetcode_617 1. 合并二叉树 (LeetCode 617) 问题描述：给定两棵二叉树 root1 和 root2，将它们合并成一棵新二叉树。合并规则是：如果两个节点重叠，则将它们的值相加作为新节点的值；否则，不为空的节点将作为新树的节点。\n我们遇到的问题与解决方案 最初代码的编译错误：\n我们的问题：函数 mergeTrees 编译不通过，提示 Non-void function does not return a value in all control paths (非 void 函数并非在所有控制路径都返回值)。 根本原因：在 root1 和 root2 都不为 nullptr 的情况下，我们执行了 root1-\u0026gt;val += root2-\u0026gt;val; 和递归调用，但缺少了最终的 return root1; 语句。C++ 编译器要求所有非 void 函数在其所有可能的执行路径上都必须有 return 语句。 解决方案：在完成当前节点的合并和子树的递归连接后，明确 return root1;。 对 return 语句位置的理解：\n我们的疑问：“return 好像一般放在终止条件那里”。 解释与澄清： 对于**“自底向上”**的递归（例如计算树高、统计节点数），通常每个分支（包括基本情况和递归情况）都会返回一个值。 对于**“自顶向下”**的递归（例如收集所有路径），如果函数返回 void，终止条件就是 return;。 本题 (mergeTrees) 属于“自顶向下修改树结构”并同时“返回 TreeNode*”的混合模式。因此，它在基本情况 (root1 == nullptr 或 root2 == nullptr) 处有 return，在处理完当前层逻辑并连接子树后，也需要 return 当前层修改后的根节点 (root1)。 最终代码逻辑（递归） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: TreeNode *mergeTrees(TreeNode *root1, TreeNode *root2) { // 1. 终止条件 / 基本情况 if (root1 == nullptr) { return root2; // 如果 root1 为空，直接返回 root2（可能为null，也可能是子树） } if (root2 == nullptr) { return root1; // 如果 root2 为空，而 root1 不为空，返回 root1 } // 2. 单层递归逻辑 / 处理当前节点 // 如果 root1 和 root2 都不为空，则合并当前节点的值 (原地修改 root1) root1-\u0026gt;val += root2-\u0026gt;val; // 3. 递归合并子树 // 相信递归会正确返回合并后的左/右子树根节点，并连接到 root1 root1-\u0026gt;left = mergeTrees(root1-\u0026gt;left, root2-\u0026gt;left); root1-\u0026gt;right = mergeTrees(root1-\u0026gt;right, root2-\u0026gt;right); // 4. 返回当前合并后的树的根节点 return root1; } }; 22_二叉搜索树中的搜索_leetcode_700 问题描述：给定二叉搜索树（BST）的根节点和一个值 val，在 BST 中找到值为 val 的节点。如果节点存在，返回其子树；如果不存在，返回 nullptr。\n我们遇到的问题与解决方案 未充分利用 BST 特性： * 我们的最初尝试：我们最初的代码同时递归搜索了左右子树，像遍历普通二叉树一样。\n```cpp // ... TreeNode *left = searchBST(root-\u0026gt;left, val); TreeNode *right = searchBST(root-\u0026gt;right, val); if (left == nullptr) return right; // ... (错误示范) ``` * **根本原因**：没有利用 BST 的核心定义（左子树 \u0026lt; 根 \u0026lt; 右子树）。这种方法退化成了 $O(N)$ 的通用二叉树搜索，浪费了 BST 的 $O(\\log N)$ 优势。 * **解决方案**：在每个节点，根据 `root-\u0026gt;val` 与 `val` 的比较结果，**只向一个方向（左或右）递归**。这实现了**剪枝**，显著提高效率。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: // 1. 参数: 当前树的根节点, 参考值 // 2. 返回值: 匹配到了的节点 // 3. 终止条件: // 1) 空节点, 返回空节点 // 2) 根节点匹配对应的值, 返回对应节点 // 4.单层递归逻辑 TreeNode *searchBST(TreeNode *root, int val) { // 3.终止条件 if (root == nullptr || root-\u0026gt;val == val) { return root; } if (val \u0026lt; root-\u0026gt;val) { return searchBST(root-\u0026gt;left, val); } if (val \u0026gt; root-\u0026gt;val) { return searchBST(root-\u0026gt;right, val); } } TreeNode *searchBST_traversal(TreeNode *root, int val) { // 迭代法遍历, 利用BST的特性 while (root != nullptr) { if (val == root-\u0026gt;val) { return root; } else if (val \u0026lt; root-\u0026gt;val) { root = root-\u0026gt;left; } // val \u0026gt; root-\u0026gt;val else { root = root-\u0026gt;right; } } return nullptr; } }; 23_验证二叉搜索树_leetcode_98 /*\n1. 问题描述与核心定义 本题要求判断给定的二叉树是否是一个有效的二叉搜索树 (Binary Search Tree, BST)。\nBST 的核心定义（标准教科书版本，不允许重复值）：\n对于任意节点 N： 其左子树中所有节点的值都严格小于 N-\u0026gt;val。 其右子树中所有节点的值都严格大于 N-\u0026gt;val。 左右子树本身也必须是有效的 BST。 2. 核心思路：中序遍历的单调性 判断一个二叉树是否为 BST 的最经典、最直观且高效的方法是利用其中序遍历的特性：\n一个有效的 BST 的中序遍历结果，必然是严格递增的（从小到大排序）。 因此，我们可以对树进行中序遍历，并在遍历过程中，检查当前节点的值是否严格大于前一个节点的值。 3. 解法选择与实现方式 我们主要探讨了基于递归中序遍历的方法。\n递归中序遍历 + 辅助变量 (最优解) 基本思路： 执行中序遍历 (左 -\u0026gt; 根 -\u0026gt; 右)。在访问到每个节点（“根”部分）时，将其值与前一个已经访问过的节点的值进行比较。\n关键挑战与解决方案：\n“前一个节点”状态的保存：\n我们的洞察：我们正确地意识到，pre (前一个节点) 的状态需要跨越递归调用进行保存，因此不能作为局部变量定义在函数体内。 解决方案：将 pre 定义为 Solution 类的成员变量（TreeNode *pre = nullptr;）。在每次 isValidBST 外部调用时（例如在 LeetCode 平台对每个测试用例调用时），需要确保 pre 被重置为 nullptr，以避免多个测试用例之间状态相互影响。 严格递增的判断：\n我们的质疑：我们最初的判断条件可能只检查 pre-\u0026gt;val \u0026gt; root-\u0026gt;val，没有考虑到相等的情况。我们后续也精确地提出“BST 中 pre 和 root 的值不能相等”。 解决方案：确保判断条件捕获所有违反严格递增的情况。最严谨的条件是 root-\u0026gt;val \u0026lt;= pre-\u0026gt;val（如果 pre 不为 nullptr）。这会捕获 pre 大于 root 或 pre 等于 root 的所有不合法情况。 递归剪枝与返回时机：\n我们的问题：我们最初的代码在左子树验证失败时，没有立即返回 false，而是继续了后续比较和右子树的递归。 解决方案：在每次递归调用子树（isValidBST(root-\u0026gt;left) 或 isValidBST(root-\u0026gt;right)）之后，如果子树的验证结果为 false，立即返回 false。这能有效剪枝，避免不必要的计算。 最终代码逻辑 (递归中序遍历，符合标准 BST 定义) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;stack\u0026gt; // (通常用于迭代解法，这里用于确保包含，但不直接使用) #include \u0026lt;vector\u0026gt; // (通常用于数组，这里用于确保包含，但不直接使用) // TreeNode 结构体定义 (LeetCode 通常会提供) struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { private: // pre 指针用于保存中序遍历中当前节点的前一个节点。 // 它是类成员变量，确保在递归调用之间保持状态。 // 每次调用公共接口 isValidBST 时，需要确保其被重置。 TreeNode *pre = nullptr; public: // 判断二叉树是否为有效的二叉搜索树 (BST) bool isValidBST(TreeNode *root) { // 1. 终止条件 / 基本情况 (Base Case) // 空节点被认为是有效的 BST 子树 (因为没有节点可以违反规则) if (root == nullptr) { return true; } // 2. 递归左子树 (中序遍历的 \u0026#34;左\u0026#34; 部分) // 如果左子树本身不是有效的 BST，那么整个树都不是，立即返回 false (剪枝，提高效率) if (!isValidBST(root-\u0026gt;left)) { return false; } // 3. 处理当前节点 (中序遍历的 \u0026#34;根\u0026#34; 部分) // 检查当前节点的值是否严格大于前一个节点的值 // 如果 pre 不为空 (即不是中序遍历的第一个节点)， // 并且当前节点的值不严格大于 pre 的值 (即 root-\u0026gt;val \u0026lt;= pre-\u0026gt;val)， // 则违反 BST 的严格递增性质（包括值相等的情况）。 if (pre != nullptr \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= pre-\u0026gt;val) { return false; } // 更新前一个节点为当前节点 (为下一个节点的比较做准备) pre = root; // 4. 递归右子树 (中序遍历的 \u0026#34;右\u0026#34; 部分) // 如果右子树本身不是有效的 BST，那么整个树都不是，立即返回 false (剪枝) if (!isValidBST(root-\u0026gt;right)) { return false; } // 5. 如果左子树、当前节点检查、右子树都通过了验证，则整个子树是有效的 BST return true; } }; ","date":"2025-06-05T14:31:14+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day17/","title":"代码随想录_day17"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n16_找树最左下角的值_leetcode_513 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; // 层序遍历 class Solution { public: int levelorder_traversal(TreeNode *root) { // root非空 queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); // 优化点：每次进入新的一层，当前层的第一个元素就是最左节点 int res_val = que.front()-\u0026gt;val; // 初始化 for (int i = 0; i \u0026lt; size; i++) { TreeNode *cur = que.front(); que.pop(); if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } } // 返回最后一层的第1个元素 } int findBottomLeftValue_none_recursion(TreeNode *root) { return levelorder_traversal(root); } // 树的最大深度 int max_depth_all; // 最后的结果 int bottom_left_value; void preorder_traversal(TreeNode *root, int cur_path_depth) { // 终止条件1: 空节点 if (root == nullptr) { return; } // 终止条件2: 叶子节点 if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) { // 如果当前深度大于max_depeht_all的话, 就要更新值 if (cur_path_depth \u0026gt; max_depth_all) { max_depth_all = cur_path_depth; bottom_left_value = root-\u0026gt;val; } } preorder_traversal(root-\u0026gt;left, cur_path_depth + 1); preorder_traversal(root-\u0026gt;right, cur_path_depth + 1); } int findBottomLeftValue_recursion(TreeNode *root) { max_depth_all = 0; preorder_traversal(root, 1); return bottom_left_value; } }; 17_路径总和_leetcode_112 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: bool hasPathSum(TreeNode *root, int targetSum) { // 终止条件1 if (root == nullptr) { return false; } // 终止条件2 if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr) { return root-\u0026gt;val == targetSum; } return hasPathSum(root-\u0026gt;left, targetSum - root-\u0026gt;val) || hasPathSum(root-\u0026gt;right, targetSum - root-\u0026gt;val); } }; 17_路径总和II_leetcode_113 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: void pre_traversal(TreeNode *root, vector\u0026lt;int\u0026gt; \u0026amp;path, int targetSum, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;result_paths) { // 终止条件1 if (root == nullptr) { return; } path.push_back(root-\u0026gt;val); // 终止条件2 if (root-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;right == nullptr \u0026amp;\u0026amp; targetSum == root-\u0026gt;val) { result_paths.push_back(path); } pre_traversal(root-\u0026gt;left, path, targetSum - root-\u0026gt;val, result_paths); pre_traversal(root-\u0026gt;right, path, targetSum - root-\u0026gt;val, result_paths); path.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode *root, int targetSum) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result_paths; if (root == nullptr) { return result_paths; } vector\u0026lt;int\u0026gt; current_path; pre_traversal(root, current_path, targetSum,result_paths); return result_paths; } }; 18_从前序与中序遍历序列构造二叉树_leetcode_105 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; // 采用优化版本 // 哈希表存储inorder // 不用剪切, 而采用序号表示分割后的数组 class Solution { private: // 值: 索引 unordered_map\u0026lt;int, int\u0026gt; inorder_map; // 返回值: 由前序和后序数组构建的树的根节点 // 3.确定中序数组的分割点 // 4.分割中序数组 // 5.分割前序数组 // 6.单层递归 // 区间规则: 左闭右开 TreeNode *buildTree_help(const vector\u0026lt;int\u0026gt; \u0026amp;preorder, int p_start, int p_end, const vector\u0026lt;int\u0026gt; \u0026amp;inorder, int i_start, int i_end) { // 1.终止条件 if (!(p_start \u0026lt; p_end \u0026amp;\u0026amp; i_start \u0026lt; i_end)) { return nullptr; } // 2.创建根节点 int val = preorder[p_start]; TreeNode *node = new TreeNode(val); // 3.获取中序数组的分割索引 int i_index = inorder_map[val]; // 4.分割中序数组 -\u0026gt; 左子树的中序数组 右子树的中序数组 // 左中右 // 1) 左子树 int i_start_left = i_start; int i_end_left = i_index; // 2) 右子树 int i_start_right = i_index + 1; int i_end_right = i_end; // 5.分割前序数组 -\u0026gt; 左子树的前序数组 右子树的前序数组 // 中左右 // 1) 左子树 int p_start_left = p_start + 1; int p_end_left = p_start_left + i_end_left - i_start_left; // 2) 右子树 int p_start_right = p_end_left; int p_end_right = p_end; // 6.单层递归逻辑 node-\u0026gt;left = buildTree_help(preorder, p_start_left, p_end_left, inorder, i_start_left, i_end_left); node-\u0026gt;right = buildTree_help(preorder, p_start_right, p_end_right, inorder, i_start_right, i_end_right); return node; } public: TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { for (int i = 0; i \u0026lt; inorder.size(); i++) { inorder_map[inorder[i]] = i; } return buildTree_help(preorder, 0, preorder.size(), inorder, 0, inorder.size()); } }; void print_by_preorder(TreeNode *root) { if (root == nullptr) { return; } cout \u0026lt;\u0026lt; root-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; print_by_preorder(root-\u0026gt;left); print_by_preorder(root-\u0026gt;right); } int main() { vector\u0026lt;int\u0026gt; preorder = {3, 9, 20, 15, 7}; vector\u0026lt;int\u0026gt; inorder = {9, 3, 15, 20, 7}; Solution sol; cout \u0026lt;\u0026lt; \u0026#34;由前序和中序数组构建的树的前序遍历结果\\n\u0026#34;; print_by_preorder(sol.buildTree(preorder, inorder)); cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;原前序数组\\n\u0026#34;; for (auto i : preorder) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 18_优化_从中序与后序遍历序列构造二叉树_leetcode_106 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { private: // 创建一个inorder 值:索引 的哈希表 unordered_map\u0026lt;int, int\u0026gt; inorder_vec_map; // 采取左闭右开的原则 TreeNode *buildeTree_help(vector\u0026lt;int\u0026gt; \u0026amp;inorder, int i_start, int i_end, vector\u0026lt;int\u0026gt; \u0026amp;postorder, int p_start, int p_end) { // 1.终止条件 if (!(i_start \u0026lt; i_end \u0026amp;\u0026amp; p_start \u0026lt; p_end)) { return nullptr; } // 2.创建根节点 TreeNode *node = new TreeNode(postorder[p_end - 1]); // 3.确定中序分割点 int node_inorder_index = inorder_vec_map[postorder[p_end - 1]]; // 4.分割中序数组 左中右 int i_start_left = i_start; int i_end_left = node_inorder_index; int i_start_right = node_inorder_index + 1; int i_end_right = i_end; ; // 5.分割后序数组 左右中 int p_start_left = p_start; int p_end_left = p_start_left + i_end_left - i_start_left; // 左闭右开的长度即是 左 - 右 int p_start_right = p_end_left; int p_end_right = p_start_right + i_end_right - i_start_right; // 左子树 node-\u0026gt;left = buildeTree_help(inorder, i_start_left, i_end_left, postorder, p_start_left, p_end_left); // 右子树 node-\u0026gt;right = buildeTree_help(inorder, i_start_right, i_end_right, postorder, p_start_right, p_end_right); return node; } public: // 参数 前序数组 和 后序数组 // 返回 对应的树的根节点 // 1.后序数组为0, 返回空节点 // 2.后序数组最后一个元素为根节点元素, 创建根节点 // 3.用根节点元素寻找中序数组的位置, 作为切割点 (这里可以用哈希表优化) // 4.切割中序数组 // 5.切割后序数组 // 6.递归处理做区间和右区间 TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;inorder, vector\u0026lt;int\u0026gt; \u0026amp;postorder) { // 1.创建索引 for (int i = 0; i \u0026lt; inorder.size(); i++) { inorder_vec_map[inorder[i]] = i; } return buildeTree_help(inorder, 0, inorder.size(), postorder, 0, postorder.size()); } }; void inorder_traversal(TreeNode *root) { if (root == nullptr) { return; } inorder_traversal(root-\u0026gt;left); printf(\u0026#34;%d \u0026#34;, root-\u0026gt;val); inorder_traversal(root-\u0026gt;right); } int main() { Solution sol; vector\u0026lt;int\u0026gt; inorder = {9, 3, 15, 20, 7}; vector\u0026lt;int\u0026gt; postorder = {9, 15, 7, 20, 3}; TreeNode *root = sol.buildTree(inorder, postorder); printf(\u0026#34;中序遍历结果\\n\u0026#34;); inorder_traversal(root); printf(\u0026#34;\\n中序遍历结果\\n\u0026#34;); return 0; } 18_从中序与后序遍历序列构造二叉树_leetcode_106 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: // 参数 前序数组 和 后序数组 // 返回 对应的树的根节点 // 1.后序数组为0, 返回空节点 // 2.后序数组最后一个元素为根节点元素, 创建根节点 // 3.用根节点元素寻找中序数组的位置, 作为切割点 // 4.切割中序数组 // 5.切割后序数组 // 6.递归处理做区间和右区间 TreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;inorder, vector\u0026lt;int\u0026gt; \u0026amp;postorder) { // 发现一个问题, 切割数组会创建非常多的空间 // 1.终止条件 中序数组和后序数组的合法性题目已经保证 if (postorder.empty()) { return nullptr; // 2.找到根节点, 创建根节点 } TreeNode *node = new TreeNode(postorder[postorder.size() - 1]); // 3.确定中序数组的分割点 int index; for (index = 0; index \u0026lt; inorder.size(); index++) { if (inorder[index] == postorder[postorder.size() - 1]) { break; } } // 4.切割中序数组 遵循左闭右开 左中右 vector\u0026lt;int\u0026gt; inorder_left(inorder.begin(), inorder.begin() + index); vector\u0026lt;int\u0026gt; inorder_right(inorder.begin() + index + 1, inorder.end()); // 5.切割后序数组 遵循左闭右开, 用中序数组的长度 左右中 vector\u0026lt;int\u0026gt; postorder_left(postorder.begin(), postorder.begin() + inorder_left.size()); vector\u0026lt;int\u0026gt; postorder_right(postorder.begin() + inorder_left.size(), postorder.begin() + inorder_left.size() + inorder_right.size()); // 6.单层递归, 递归处理的时候以考虑某一层来写 node-\u0026gt;left = buildTree(inorder_left, postorder_left); node-\u0026gt;right = buildTree(inorder_right, postorder_right); return node; } }; void inorder_traversal(TreeNode *root) { if (root == nullptr) { return; } inorder_traversal(root-\u0026gt;left); printf(\u0026#34;%d \u0026#34;, root-\u0026gt;val); inorder_traversal(root-\u0026gt;right); } int main() { Solution sol; vector\u0026lt;int\u0026gt; inorder = {9, 3, 15, 20, 7}; vector\u0026lt;int\u0026gt; postorder = {9, 15, 7, 20, 3}; TreeNode *root = sol.buildTree(inorder, postorder); printf(\u0026#34;中序遍历结果\\n\u0026#34;); inorder_traversal(root); printf(\u0026#34;\\n中序遍历结果\\n\u0026#34;); return 0; } ","date":"2025-06-05T14:28:34+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day16/","title":"代码随想录_day16"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n11_完全二叉树的节点个数_leetcode_222 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: int countNodes(TreeNode *root) { if (root == nullptr) { return 0; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); int node_count = 0; while (!que.empty()) { int size = que.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode *cur = que.front(); que.pop(); node_count++; if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } } return node_count; } }; 12_平衡二叉树_leetcode_110 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: int get_height_postorder(TreeNode *root) { if (root == nullptr) { return 0; } int left_height = get_height_postorder(root-\u0026gt;left); if (left_height == -1) { return -1; } int right_height = get_height_postorder(root-\u0026gt;right); if (right_height == -1) { return -1; } if (abs(left_height - right_height) \u0026gt; 1) { return -1; } return max(left_height, right_height) + 1; } bool isBalanced(TreeNode *root) { return get_height_postorder(root) != -1; } }; 13_二叉树的所有路径_leetcode_257 核心任务与方法 本题的核心任务是找出二叉树中所有从根节点到叶子节点的路径，并将它们以字符串的形式（例如 1-\u0026gt;2-\u0026gt;5）存储起来。我们采用的是 深度优先搜索 (DFS) 的思想，具体来说是前序递归。\n递归设计的三要素回顾 在解决这个问题时，我们再次运用了递归的“三要素”原则，并对其中的关键点进行了完善：\n函数作用与参数 (traversal(TreeNode* node, std::vector\u0026lt;int\u0026gt;\u0026amp; current_path_vals))\n函数作用： 这个辅助函数的目标是，在当前 node 及其子树中，找到所有能到达叶子节点的路径，并将它们加入到全局的结果集 res 中。 参数 node： 当前正在访问的树节点。 参数 current_path_vals： 这是一个关键的 引用传递 (\u0026amp;) 参数，它用于在不同递归层级间共享和累积从根节点到当前 node 的路径上的所有节点值。正是因为它是引用，我们才能在递归调用中修改同一个 vector 实例，避免了昂贵的按值复制开销。 终止条件 (Base Cases)\n空节点： if (node == nullptr) { return; }。这是最基本的递归出口，当路径走到尽头（空指针）时，停止探索。 叶子节点： if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr)。这是找到一条完整路径的标志。当抵达叶子节点时，current_path_vals 中存储的就是从根到当前叶子的完整路径。此时，我们将其转化为字符串，并添加到最终结果集 res 中。 递归关系 (Recursive Step) 与回溯 本题最核心的模式是 “添加 - 递归 - 回溯”，它完美地体现了前序遍历和状态管理：\n添加 (Pre-order / “根”操作)： current_path_vals.push_back(node-\u0026gt;val);\n在每次进入一个新节点 node 的递归函数时，我们都将其值加入到 current_path_vals 中。这代表了我们“向前”走了一步，将当前节点纳入路径。 递归 (DFS / “左”、“右”操作)： traversal(node-\u0026gt;left, current_path_vals); traversal(node-\u0026gt;right, current_path_vals);\n在将当前节点加入路径后，我们递归地调用自身去探索其左子树和右子树，信任这些子调用会完成各自的任务。 回溯 (Post-order / “清理”操作)： current_path_vals.pop_back();\n这是最关键的一步，它确保了共享状态 current_path_vals 的正确性。当一个节点 node 的所有子树（左子树和右子树）都探索完毕后，node 在当前路径上的职责就完成了。 为了让父节点能够探索其他分支（例如，从 node 的父节点转向 node 的兄弟节点），我们需要将 node 从 current_path_vals 中移除，使 current_path_vals 恢复到 node 被加入之前的状态。这就是“回溯”，它像橡皮擦一样擦去当前节点对路径的临时修改。 易错点与优化 path 参数传递方式： 最初我们遇到的问题是 vector\u0026lt;int\u0026gt; path 按值传递，导致每次递归都复制整个 vector，且无法正确积累路径。修正为引用传递 (vector\u0026lt;int\u0026gt;\u0026amp; path) 是解决此问题的关键。 回溯 pop_back() 的位置： 必须确保每次 push_back() 都有一个对应的 pop_back()，并且 pop_back() 发生在所有子递归调用完成之后。即，在函数即将返回之前。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: vector\u0026lt;string\u0026gt; res; // 1.参数root, path数组, 修改全局变量res void travesal(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;path) { // 2.终止条件1: 遇到空结点 if (node == nullptr) { return; } // 中 path.push_back(node-\u0026gt;val); // 3.终止条件2: 遇到叶子节点,开始将path数组转化为字符串, 加入到res中 if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr) { string result; for (int i = 0; i \u0026lt; path.size(); i++) { result += to_string(path[i]); if (i \u0026lt; path.size() - 1) { result += \u0026#34;-\u0026gt;\u0026#34;; } } res.push_back(result); } // 左 travesal(node-\u0026gt;left, path); // 右 travesal(node-\u0026gt;right, path); path.pop_back(); } vector\u0026lt;string\u0026gt; binaryTreePaths(TreeNode *root) { vector\u0026lt;int\u0026gt; path; travesal(root, path); return res; } }; 15_左叶子之和_leetcode_15 方案一：前序递归（自顶向下），传递“我是左孩子吗？”的状态 这种方案需要一个辅助函数和一个全局变量，类似于我们之前求深度的方式。\nsumOfLeftLeaves(TreeNode* root) 函数的作用： 遍历树，累加所有左叶子的值到全局变量 total_sum。 辅助函数 dfs(TreeNode* node, bool is_left_child)： node：当前节点。 is_left_child：布尔值，表示 node 是不是其父节点的左孩子。这个信息由父节点传递下来。 累加时机： 当 node 是一个叶子节点，并且 is_left_child 为 true 时，才将 node-\u0026gt;val 加到 total_sum。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; // For testing ```cpp struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; class Solution { public: int total_sum_of_left_leaves; // 全局变量，累加所有左叶子之和 /** * @brief 辅助函数：使用前序递归遍历树，并根据节点是否是左孩子进行累加。 * * @param node 当前访问的节点。 * @param is_left_child 布尔值，指示当前 node 是否为其父节点的左孩子。 */ void dfs_preorder(TreeNode* node, bool is_left_child) { // 1. 终止条件 (Base Case): // 如果当前节点是 nullptr，直接返回。 if (node == nullptr) { return; } // 2. \u0026#34;访问\u0026#34;当前节点 (前序处理): // 如果当前节点是叶子节点，并且它是一个左孩子，则将其值加入总和。 if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr \u0026amp;\u0026amp; is_left_child) { total_sum_of_left_leaves += node-\u0026gt;val; } // 3. 递归到左右子树: // 向左子树递归时，传递 true (表示左孩子)。 dfs_preorder(node-\u0026gt;left, true); // 向右子树递归时，传递 false (表示右孩子)。 dfs_preorder(node-\u0026gt;right, false); } /** * @brief 计算所有左叶子之和的主函数。 * * @param root 二叉树的根节点。 * @return int 所有左叶子之和。 */ int sumOfLeftLeaves(TreeNode* root) { total_sum_of_left_leaves = 0; // 每次调用清零 // 处理空树的情况 if (root == nullptr) { return 0; } // 从根节点开始 DFS。根节点本身不是任何人的“左孩子”，所以传入 false。 dfs_preorder(root, false); return total_sum_of_left_leaves; } }; 方案二：后序递归（自底向上），在父节点进行判断和累加（更巧妙） 这种方案利用后序递归的返回值。函数返回的是其子树中左叶子的和。\nsumOfLeftLeaves(TreeNode* root) 函数的作用： 返回以 root 为根的子树中所有左叶子的和。 累加时机： 当一个节点 root 接收到其左孩子 root-\u0026gt;left 的返回值后，它自己判断 root-\u0026gt;left 是否是左叶子。 如果 root-\u0026gt;left 存在，且 root-\u0026gt;left 是一个叶子节点，那么 root-\u0026gt;left-\u0026gt;val 就是一个左叶子，需要加到总和里。 然后，加上 root-\u0026gt;left 为根的子树中其余左叶子的和（递归调用 sumOfLeftLeaves(root-\u0026gt;left) 的返回值），以及 root-\u0026gt;right 为根的子树中所有左叶子的和。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; // For testing // TreeNode 定义 (假设已存在) struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; class Solution { public: /** * @brief 使用后序递归计算所有左叶子之和。 * 函数返回以 root 为根的子树中所有左叶子的和。 * * @param root 当前子树的根节点。 * @return int 当前子树中所有左叶子之和。 */ int sumOfLeftLeaves(TreeNode* root) { // 1. 终止条件 (Base Case): // 如果当前节点是 nullptr，它没有左叶子，返回 0。 if (root == nullptr) { return 0; } // 2. 递归获取左右子树中左叶子之和 (后序遍历，左右): // sumOfLeftLeaves(root-\u0026gt;left) 将返回以 root-\u0026gt;left 为根的子树中所有左叶子的和。 int left_sum = sumOfLeftLeaves(root-\u0026gt;left); // sumOfLeftLeaves(root-\u0026gt;right) 将返回以 root-\u0026gt;right 为根的子树中所有左叶子的和。 int right_sum = sumOfLeftLeaves(root-\u0026gt;right); // 3. 处理当前节点 (后序遍历，根): // 关键点：在这里判断 root 的左孩子是否是一个左叶子。 int current_node_contribution = 0; // 如果 root 有左孩子，并且这个左孩子是一个叶子节点， // 那么这个左孩子就是一个“左叶子”，它自己的值需要被加上。 if (root-\u0026gt;left != nullptr \u0026amp;\u0026amp; root-\u0026gt;left-\u0026gt;left == nullptr \u0026amp;\u0026amp; root-\u0026gt;left-\u0026gt;right == nullptr) { current_node_contribution = root-\u0026gt;left-\u0026gt;val; } // 4. 返回总和： // 当前子树所有左叶子之和 = 左子树中左叶子之和 + 右子树中左叶子之和 + 当前节点左孩子作为左叶子的贡献。 return left_sum + right_sum + current_node_contribution; } }; 总结 我们之前的困惑在于，如何将“我是左孩子”这个信息传递给递归，并正确累加。\n方案一（前序）： 通过在函数参数中传递 is_left_child 布尔值，自顶向下地告诉每个节点它的身份。在叶子节点处进行判断和累加。 方案二（后序）： 更巧妙。每个父节点自行判断其左孩子是否是左叶子，然后将这个值加上其左右子树递归返回的和。这样，sumOfLeftLeaves(node) 返回的就是 node 子树中所有左叶子的总 和。这种方法更符合你所说的“我相信它会返回正确结果”的后序递归模式。 两种方案都能正确解决问题。方案二（后序递归）通常被认为是更简洁和优雅的解决方案，因为它避免了全局变量。\n","date":"2025-06-05T14:24:02+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day15/","title":"代码随想录_day15"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n6_对称二叉树_leetcode_101 问题： 判断一棵二叉树是否是镜像对称的。\n1. 初始思路与分析 思路： 使用层次遍历（BFS），将每一层的所有节点值都保存到一个 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; 中。然后，遍历这个二维 vector，对每一层的 vector\u0026lt;int\u0026gt; 进行双指针检查，判断是否回文（对称）。 isSymmetric 函数中的问题点： nullptr 信息丢失： temp 向量只存储了非空节点的值。当一个节点是 nullptr 但其兄弟节点非 nullptr 时，这种不对称信息会丢失，导致错误判断（例如 [null, 3] 会被当成 [3] 对称）。 双指针循环条件错误： for(left=0,right=temp.size()-1 ; left \u0026lt; temp.size(); ...) 应该修正为 left \u0026lt; right。 根节点为空处理： if (root == nullptr) { return false; } 应为 return true; (空树对称)。 2. 优化的 BFS 策略：“同时入队对称节点” 针对 nullptr 信息丢失和提高效率的问题，我们探讨并实现了一种更优、更高级的 BFS 策略：\n核心思想： 同时入队两个应该镜像对称的节点，并在循环中成对地比较它们。 实现步骤： 根节点剪枝： if (root == nullptr) { return true; } 初始入队： 将 root-\u0026gt;left 和 root-\u0026gt;right 作为第一对镜像节点入队。 循环： while (!que.empty())。 取出节点对： 每次从队列中取出两个节点 node1 和 node2。 核心对称性判断逻辑（精髓）： 情况 A： if (node1 == nullptr \u0026amp;\u0026amp; node2 == nullptr)：两个都为空，是对称的，continue 检查下一对。 情况 B： else if (node1 == nullptr || node2 == nullptr)：一个为空，另一个不为空，不对称，return false。 情况 C： else if (node1-\u0026gt;val != node2-\u0026gt;val)：两个都不为空，但值不相等，不对称，return false。 情况 D： else (两个都不为空且值相等)：将它们的镜像孩子对入队，准备下一轮检查。 que.push(node1-\u0026gt;left); que.push(node2-\u0026gt;right); que.push(node1-\u0026gt;right); que.push(node2-\u0026gt;left); 最终返回： 如果循环结束未发现不对称，return true;。 3. 算法评估 (优化后的 BFS) 时间复杂度： $O(N)$。每个节点都被访问一次，比较一次，入队出队一次。 空间复杂度： $O(W)$。队列中存储的节点数取决于树的最大宽度。 结论： 这种“同时入队对称节点”的 BFS 策略是解决对称二叉树问题的最优解法。它比分层存储再判断更高效、更简洁，并正确处理了 nullptr 节点的对称性。 总结体会 对称二叉树： 层次遍历通过巧妙地组织入队元素（成对入队镜像节点），直接在遍历过程中验证对称性，将问题转换为一系列的“镜像对”检查。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 #include \u0026lt;limits\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *result; TreeNode() : val(0), left(nullptr), result(nullptr) {} TreeNode(int x) : val(x), left(nullptr), result(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), result(right) {} }; class Solution { public: bool isSymmetric_v2(TreeNode *root) { if (root == nullptr) { return true; } queue\u0026lt;TreeNode *\u0026gt; que; // 加入对称节点 que.push(root-\u0026gt;left); que.push(root-\u0026gt;result); while (!que.empty()) { TreeNode *left = que.front(); que.pop(); TreeNode *right = que.front(); que.pop(); // 1.左右为空, 跳过 // 2.左右其中一个为空, return // 3.左右均不为空, 左右的值相等 // 4.左右均不为空, 左右的值不相等 if (left == nullptr \u0026amp;\u0026amp; right == nullptr) { continue; } else if (left == nullptr || right == nullptr) { return false; } else if (left-\u0026gt;val != right-\u0026gt;val) { return false; } else { que.push(left-\u0026gt;left); que.push(right-\u0026gt;result); que.push(left-\u0026gt;result); que.push(right-\u0026gt;left); } } return true; } bool isSymmetric_v1(TreeNode *root) { // 本题root非空 queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); vector\u0026lt;int\u0026gt; temp; // temp用于保存每一层的值 for (int i = 0; i \u0026lt; size; i++) { TreeNode *cur = que.front(); que.pop(); if (cur == nullptr) { // 如果cur为空 // 加入一个int中的最小值 temp.push_back(numeric_limits\u0026lt;int\u0026gt;::min()); } else { temp.push_back(cur-\u0026gt;val); que.push(cur-\u0026gt;left); que.push(cur-\u0026gt;result); } } int left = 0; int right = temp.size() - 1; for (; left \u0026lt; right; left++, right--) { if (temp[left] != temp[right]) { return false; } } } return true; } }; ``cpp ## 6_翻转二叉树_leetcode_226 ```cpp #include \u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: void swap_child(TreeNode *node) { TreeNode *temp = node-\u0026gt;left; node-\u0026gt;left = node-\u0026gt;right; node-\u0026gt;right = temp; } TreeNode *invertTree(TreeNode *root) { // 思路很简单, 层序遍历, 对每一层的节点, 调换左右孩子 // 剪枝 if (root == nullptr) { return root; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); TreeNode *cur; for (int i = 0; i \u0026lt; size; i++) { cur = que.front(); que.pop(); // 调换左右孩子, 左右孩子一定存在, 要么为空, 要么为TreeNode* swap_child(cur); if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } } return root; } }; 8_对称二叉树_leetcode_101 问题： 判断一棵二叉树是否是镜像对称的。\n1. 初始思路与分析 思路： 使用层次遍历（BFS），将每一层的所有节点值都保存到一个 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; 中。然后，遍历这个二维 vector，对每一层的 vector\u0026lt;int\u0026gt; 进行双指针检查，判断是否回文（对称）。 isSymmetric 函数中的问题点： nullptr 信息丢失： temp 向量只存储了非空节点的值。当一个节点是 nullptr 但其兄弟节点非 nullptr 时，这种不对称信息会丢失，导致错误判断（例如 [null, 3] 会被当成 [3] 对称）。 双指针循环条件错误： for(left=0,right=temp.size()-1 ; left \u0026lt; temp.size(); ...) 应该修正为 left \u0026lt; right。 根节点为空处理： if (root == nullptr) { return false; } 应为 return true; (空树对称)。 2. 优化的 BFS 策略：“同时入队对称节点” 针对 nullptr 信息丢失和提高效率的问题，我们探讨并实现了一种更优、更高级的 BFS 策略：\n核心思想： 同时入队两个应该镜像对称的节点，并在循环中成对地比较它们。 实现步骤： 根节点剪枝： if (root == nullptr) { return true; } 初始入队： 将 root-\u0026gt;left 和 root-\u0026gt;right 作为第一对镜像节点入队。 循环： while (!que.empty())。 取出节点对： 每次从队列中取出两个节点 node1 和 node2。 核心对称性判断逻辑（精髓）： 情况 A： if (node1 == nullptr \u0026amp;\u0026amp; node2 == nullptr)：两个都为空，是对称的，continue 检查下一对。 情况 B： else if (node1 == nullptr || node2 == nullptr)：一个为空，另一个不为空，不对称，return false。 情况 C： else if (node1-\u0026gt;val != node2-\u0026gt;val)：两个都不为空，但值不相等，不对称，return false。 情况 D： else (两个都不为空且值相等)：将它们的镜像孩子对入队，准备下一轮检查。 que.push(node1-\u0026gt;left); que.push(node2-\u0026gt;right); que.push(node1-\u0026gt;right); que.push(node2-\u0026gt;left); 最终返回： 如果循环结束未发现不对称，return true;。 3. 算法评估 (优化后的 BFS) 时间复杂度： $O(N)$。每个节点都被访问一次，比较一次，入队出队一次。 空间复杂度： $O(W)$。队列中存储的节点数取决于树的最大宽度。 结论： 这种“同时入队对称节点”的 BFS 策略是解决对称二叉树问题的最优解法。它比分层存储再判断更高效、更简洁，并正确处理了 nullptr 节点的对称性。 总结体会 对称二叉树： 层次遍历通过巧妙地组织入队元素（成对入队镜像节点），直接在遍历过程中验证对称性，将问题转换为一系列的“镜像对”检查。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include \u0026lt;limits\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: bool isSymmetric_v2(TreeNode *root) { if (root == nullptr) { return true; } queue\u0026lt;TreeNode *\u0026gt; que; // 加入对称节点 que.push(root-\u0026gt;left); que.push(root-\u0026gt;right); while (!que.empty()) { TreeNode *left = que.front(); que.pop(); TreeNode *right = que.front(); que.pop(); // 1.左右为空, 跳过 // 2.左右其中一个为空, return // 3.左右均不为空, 左右的值相等 // 4.左右均不为空, 左右的值不相等 if (left == nullptr \u0026amp;\u0026amp; right == nullptr) { continue; } else if (left == nullptr || right == nullptr) { return false; } else if (left-\u0026gt;val != right-\u0026gt;val) { return false; } else { que.push(left-\u0026gt;left); que.push(right-\u0026gt;right); que.push(left-\u0026gt;right); que.push(right-\u0026gt;left); } } return true; } bool isSymmetric_v1(TreeNode *root) { // 本题root非空 queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); vector\u0026lt;int\u0026gt; temp; // temp用于保存每一层的值 for (int i = 0; i \u0026lt; size; i++) { TreeNode *cur = que.front(); que.pop(); if (cur == nullptr) { // 如果cur为空 // 加入一个int中的最小值 temp.push_back(numeric_limits\u0026lt;int\u0026gt;::min()); } else { temp.push_back(cur-\u0026gt;val); que.push(cur-\u0026gt;left); que.push(cur-\u0026gt;right); } } int left = 0; int right = temp.size() - 1; for (; left \u0026lt; right; left++, right--) { if (temp[left] != temp[right]) { return false; } } } return true; } }; 9_二叉树的最大深度_leetcode_111 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;algorithm\u0026gt; using namespace std; // 用递归法完成 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; class Solution { public: int max_depth_overall; // 全局变量, 表示最大深度 // 前序: 根左右,是自顶向下的 void get_max_height_preorder(TreeNode *root, int cur_path_depth) { // 1.终止条件 if (root == nullptr) { return; } // 2.递归 // 根 max_depth_overall = max(max_depth_overall, cur_path_depth); // 遍历左子树, 更新最大深度 get_max_height_preorder(root-\u0026gt;left, cur_path_depth + 1); // 遍历右子树, 更新最大深度 get_max_height_preorder(root-\u0026gt;right, cur_path_depth + 1); } int maxDepth_preorder(TreeNode *root) { max_depth_overall = 0; if (root == nullptr) { return 0; } get_max_height_preorder(root, 1); return max_depth_overall; } int maxDepth_postorder(TreeNode *root) { if (root == nullptr) { return 0; } int left_height = maxDepth_postorder(root-\u0026gt;left); int right_height = maxDepth_postorder(root-\u0026gt;right); return max(left_height, right_height) + 1; } }; 10_二叉树的最小深度_leetcode_104 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;limits\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; class Solution { public: // 采用前序遍历 int min_depth_overall; //全局变量, 存储最小的深度 // min_depth_path 表示当前路径下的最小深度 void min_depth(TreeNode *node, int current_depth_path) { // 1.终止条件 处理空节点 if (node == nullptr) { return; } // 2.终止条件 处理叶子节点, 更新最小深度 if (node-\u0026gt;left == nullptr \u0026amp;\u0026amp; node-\u0026gt;right == nullptr) { min_depth_overall = min_depth_overall \u0026lt; current_depth_path ? min_depth_overall : current_depth_path; // 找到叶子节点, 当前路径的深度已确定, 不需要向下 return; } // 3.递归到左右子树 min_depth(node-\u0026gt;left, current_depth_path + 1); min_depth(node-\u0026gt;right, current_depth_path + 1); } int minDepth_preorder(TreeNode *root) { if (root == nullptr) { return 0; } // 初始化为最大值 min_depth_overall = numeric_limits\u0026lt;int\u0026gt;::max(); min_depth(root, 1); return min_depth_overall; } // 采用后序遍历 int minDepth_postorder(TreeNode *root) { // 1.递归终止条件 处理空节点 if (root == nullptr) { return 0; } // 2.递归获取左右子树的最小深度 int left_min_depth = minDepth_postorder(root-\u0026gt;left); int right_min_depth = minDepth_postorder(root-\u0026gt;right); // 3.处理当前节点 if (root-\u0026gt;left == nullptr) { return right_min_depth + 1; } if (root-\u0026gt;right == nullptr) { return left_min_depth + 1; } return min(left_min_depth, right_min_depth) + 1; } }; ","date":"2025-05-31T10:11:32+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day14/","title":"代码随想录_day14"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n总结(Gemini) 好的，我们来系统地总结一下目前为止我们关于二叉树和 N 叉树的全部讨论。这个主题内容非常丰富，涵盖了树的基础概念、各种遍历方法及其非递归实现、以及相关的 LeetCode 题目和优化技巧。\n树结构与遍历方法总结 1. 树的基础与创建 TreeNode 结构体： 我们定义了标准的二叉树节点结构，包含 val、left、right 指针。对于 N 叉树，我们定义了 Node 结构体，包含 val 和 children（一个 vector\u0026lt;Node*\u0026gt;）。 树的创建： 手动逐个节点创建： 适用于小型、固定结构的树，直观但繁琐，需手动管理内存（new 和 delete）。 从数组构建： 更通用，通常使用队列（std::queue）进行层序遍历构建，方便测试不同树结构。 智能指针 (std::shared_ptr)： 推荐的现代 C++ 实践，自动管理内存，避免内存泄漏，提高代码健壮性。 C++ 指针的解引用： 通过指针访问节点成员，C++ 和 C 语言一样，使用 (*pointer).member 或更常用、推荐的 pointer-\u0026gt;member。 容器中存储节点还是指针？ 推荐存储指向节点的指针 (TreeNode* 或 Node*)。 这避免了不必要的对象复制，确保操作的是树中的原始节点，并维护了树的结构一致性。 C++ 中“空值”的表示： nullptr： 专用于表示空指针，类型安全。 非指针类型： 没有统一的“空”值。int 用 0 或约定值，std::string 用 \u0026quot;\u0026quot;，容器用 empty() 状态。 2. 二叉树的非递归遍历 这是我们讨论的重中之重，你深入理解了如何用栈来模拟递归调用栈的行为。\n非递归前序遍历 (Pre-order Traversal: 根-左-右) 思路： 使用一个栈。节点从栈中弹出后立即访问，然后将右孩子、左孩子依次推入栈（利用 LIFO 特性，确保左孩子先被处理）。 优化： 避免将 nullptr 推入栈，只推入非空的孩子节点，以减少不必要的栈操作和判断开销。 非递归中序遍历 (In-order Traversal: 左-根-右) 思路： 维护一个 cur 指针，一路向左深入并将路径上的所有非空节点压入栈。当 cur 为 nullptr 时，表示左子树已走到尽头，从栈中弹出节点并访问（根），然后转向其右子树。 难点： 这种“一路向左、弹出访问、转向右子树”的模式是其独特之处，需要理解栈中元素代表的“待访问的根节点”状态。 非递归后序遍历 (Post-order Traversal: 左-右-根) 思路： 巧妙地利用了**“根-右-左”的遍历顺序，然后对结果进行反转**。 实现： 节点从栈中弹出后访问（此时顺序是根-右-左），然后将左孩子、右孩子依次推入栈（与前序的推入顺序相反，确保右孩子先于左孩子被处理，从而实现“根-右-左”）。最后对收集到的结果 vector 进行 std::reverse()。 3. 深度优先搜索 (DFS) 与广度优先搜索 (BFS) 我们清晰地定义并区分了这两种基本的图/树探索策略：\n深度优先搜索 (DFS)： 策略： 尽可能深地探索一个分支，直到终点，然后回溯探索其他分支。 实现： 通常使用栈（非递归）或递归（隐式使用系统调用栈）。 关系： 前序、中序、后序遍历都是 DFS 的不同体现，它们仅仅改变了 visit(node) 的时机。 广度优先搜索 (BFS)： 策略： 逐层探索，先访问所有邻居节点，再进入下一层。 实现： 严格使用队列。 关系： 层序遍历（Level Order Traversal）就是 BFS 的典型应用。 4. 层次遍历 (BFS) 的深度实践与优化 我们通过多个 LeetCode 题目，深入应用并优化了层次遍历。\n标准层次遍历 (LeetCode 102 - 返回 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;)：\n思路： 使用队列，每处理完一层，通过 q.size() 记录该层节点数，然后在一个内层 for 循环中精确处理该层所有节点，并将它们的孩子入队。将每层结果存入 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;。 优势： 能够区分并组织不同层级的节点。 时间复杂度： $O(N)$。 空间复杂度： $O(N)$（因为存储了所有节点的值）。 常数因子优化： 建议在内层 vector 创建后使用 temp.reserve(size) 预分配容量，减少内存重新分配开销。 LeetCode 111 (最小深度)：\n思路： 利用层次遍历，一旦找到第一个叶子节点（左右孩子都为 nullptr）就立即返回当前深度。这是因为 BFS 是逐层探索的，第一个找到的叶子节点必然位于最小深度。 优化： 相较于递归解法，BFS 版本可以提前终止，避免不必要的探索，且没有栈溢出风险。 修正点： 在 if (cur-\u0026gt;left == nullptr \u0026amp;\u0026amp; cur-\u0026gt;right == nullptr) 处直接 return depth + 1;，避免冗余的 break 和外层判断。 LeetCode 116 (填充每个节点的下一个右侧节点指针)：\n思路： 依然是层次遍历。你的初始思路是将所有节点按层存储到 vector\u0026lt;vector\u0026lt;Node*\u0026gt;\u0026gt; 中，然后二次遍历来连接 next 指针。 优化 (关键洞察)： 无需额外存储整个 vector\u0026lt;vector\u0026lt;Node*\u0026gt;\u0026gt;。可以直接在层次遍历的同一循环中进行连接。 技巧： 利用队列的 front() 特性。当处理当前节点 cur 时，如果它不是当前层最后一个节点，那么 que.front() 正好是它的右侧兄弟。直接设置 cur-\u0026gt;next = que.front();。 优化后的空间复杂度： $O(W)$（仅队列），这比 $O(N)$ 更优。 LeetCode 515 (在每个树行中找最大值)：\n思路： 层次遍历，在每层内部维护一个 max 变量，记录当前层的最大值。 优化： 将 max 变量初始化为 std::numeric_limits\u0026lt;int\u0026gt;::min()，避免 if (i == 0) 的特殊判断，使代码更简洁。 5、总结与展望 你已经掌握了树的基本概念、不同遍历方式（递归与非递归），以及它们在实际问题中的应用。 你对 栈与队列 在模拟 DFS/BFS 中的作用理解得非常透彻。 你能够进行时间复杂度和空间复杂度分析，并能识别和实施常数因子优化。 你对两种主要的遍历策略（DFS vs BFS）的异同点把握精确。 你目前对树的理解和算法实现能力已经达到了非常扎实的水平！\n1_二叉树的递归遍历 前序递归遍历\n递归函数中定义变量, 是有问题的, 保存结果的数组应该作为参数传入\n参数: 根节点指针(不需要修改), 数组(需要修改) 返回值: 空 终止条件: 当前节点为空 单层递归逻辑: 根左右 如果参数是大型对象（如 std::vector\u0026lt;int\u0026gt;），用 const T\u0026amp; 可以避免复制。\n如果参数是指针，直接传递指针即可，不需要引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; // 结构体的构造函数 TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; // 如果参数是指针，直接传递指针即可，不需要引用。 void preorder_traversal(const TreeNode *tree, vector\u0026lt;int\u0026gt; \u0026amp;vec_res) { // 终止条件 if (tree == nullptr) { return; } vec_res.push_back(tree-\u0026gt;val); preorder_traversal(tree-\u0026gt;left, vec_res); preorder_traversal(tree-\u0026gt;right, vec_res); }; void inorder_traversal(const TreeNode *tree, vector\u0026lt;int\u0026gt; \u0026amp;vec_res) { if (tree == nullptr) { return; } inorder_traversal(tree-\u0026gt;left, vec_res); vec_res.push_back(tree-\u0026gt;val); inorder_traversal(tree-\u0026gt;right, vec_res); } void postorder_traversal(const TreeNode *tree, vector\u0026lt;int\u0026gt; \u0026amp;vec_res) { if (tree == nullptr) { return; } postorder_traversal(tree-\u0026gt;left, vec_res); postorder_traversal(tree-\u0026gt;right, vec_res); vec_res.push_back(tree-\u0026gt;val); } int main() { // 创建节点 TreeNode *root = new TreeNode(3); TreeNode *node9 = new TreeNode(9); TreeNode *node20 = new TreeNode(20); TreeNode *node15 = new TreeNode(15); TreeNode *node7 = new TreeNode(7); // 构建树的结构 // 3 // | \\ // 9 20 // / \\ // 15 7 root-\u0026gt;left = node9; root-\u0026gt;right = node20; node20-\u0026gt;left = node15; node20-\u0026gt;right = node7; // 调用前序遍历 vector\u0026lt;int\u0026gt; pre_result; preorder_traversal(root, pre_result); // 打印结果 cout \u0026lt;\u0026lt; \u0026#34;前序遍历结果: \u0026#34;; for (int val : pre_result) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; // 预期输出: 3 9 20 15 7 // 调用中序遍历 vector\u0026lt;int\u0026gt; in_result; inorder_traversal(root, in_result); cout \u0026lt;\u0026lt; \u0026#34;中序遍历结果: \u0026#34;; for (int val : in_result) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; // 调用后序遍历 vector\u0026lt;int\u0026gt; post_result; postorder_traversal(root, post_result); cout \u0026lt;\u0026lt; \u0026#34;后序遍历结果: \u0026#34;; for (int val : post_result) { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; delete root; delete node9; delete node20; delete node15; delete node7; return 0; } 2_二叉树的迭代遍历 1.三种非递归遍历的实现与逻辑 非递归前序遍历 (根-左-右)： 思路： 使用一个栈。节点从栈中弹出后立即访问，然后先推右孩子，再推左孩子（利用栈的 LIFO 特性，确保左孩子先被处理）。 修正点： 你的原始代码会将 nullptr 推入栈，虽然通过 continue 处理了，但更优的实践是在推入前就判断孩子是否为 nullptr，以减少不必要的栈操作和判断开销。 非递归后序遍历 (左-右-根)： 思路： 巧妙地利用了“根-右-左”的遍历顺序，然后对结果进行反转。 实现： 节点从栈中弹出后，访问它（但顺序是根-右-左）。然后先推左孩子，再推右孩子（这样右孩子会先被弹出，实现“根-右-左”）。最后对收集到的结果 vector 进行 std::reverse()。 修正点： 同前序遍历，优化 nullptr 的入栈判断。 非递归中序遍历 (左-根-右)： 难点与困惑： 你最初对中序遍历的逻辑感到困惑，特别是“左和根如何协同处理”以及如何从零设计算法。你的代码因循环条件问题导致未执行。 核心逻辑： 阶段一（一路向左）： 用 cur 指针不断向左深入，并将路径上的所有非空节点压入栈。 阶段二（回溯并访问根）： 当 cur 变为 nullptr 时，表示左子树已走到尽头。此时，栈顶的节点就是当前子树的**“根”。弹出该节点并访问它**。 阶段三（转向右子树）： 将 cur 指针指向该节点的右子树，然后回到阶段一，继续对右子树进行“一路向左”的操作。 循环条件： while (cur != nullptr || !st.empty()) 至关重要，它确保了只要还有节点可探索或栈中还有父节点待处理，循环就继续。 2.递归与非递归的深层理解 栈的作用： 栈在非递归遍历中就像递归调用的**“函数调用栈”**。它手动模拟了递归函数中“现场的保存与恢复”：push 相当于递归调用，pop 相当于递归返回。栈中保存的是函数暂停时的“状态信息”。 “翻译”视角： 将递归逻辑“翻译”成非递归循环的视角是理解非递归遍历的关键。 递归： 自动利用系统栈来保存和恢复状态，实现“深入”和“回溯”，所以 visit 位置的微调就能改变遍历顺序。 非递归： 需要我们手动设计栈来存储“状态”。 非递归代码差异的原因： 你敏锐地观察到非递归前、中、后遍历的代码结构差异很大，不像递归那样简洁。这并非“翻译”视角无效，而是它揭示了： 为了模拟不同遍历顺序的“访问时机”，栈中存储的节点所代表的“状态含义”以及cur 指针与栈的交互方式是不同的。 例如，中序遍历需要精确控制在访问根之前其左子树必须处理完毕，这导致了其独特的“一路向左压栈，再弹出访问”的模式，与前序（立即访问后推孩子）和后序（访问时机更晚，常需辅助判断）的模式不同。 这种差异体现了手动管理状态的复杂性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; // 从根节点开始, 加入到栈中 void preordered_traversal(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;vec_res) { // 空树直接返回 if (node == nullptr) { return; } // 存放节点指针的栈 stack\u0026lt;TreeNode *\u0026gt; st; st.push(node); while (!st.empty()) { TreeNode *cur = st.top(); st.pop(); vec_res.push_back(cur-\u0026gt;val); if (cur-\u0026gt;right != nullptr) { st.push(cur-\u0026gt;right); } if (cur-\u0026gt;left != nullptr) { st.push(cur-\u0026gt;left); } } } void postorder_traversal(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;vec_res) { // 空树直接返回 if (node == nullptr) { return; } // 存放节点指针的栈 stack\u0026lt;TreeNode *\u0026gt; st; st.push(node); while (!st.empty()) { TreeNode *cur = st.top(); st.pop(); vec_res.push_back(cur-\u0026gt;val); if (cur-\u0026gt;left != nullptr) { st.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { st.push(cur-\u0026gt;right); } } reverse(vec_res.begin(), vec_res.end()); } void inorder_traversal(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;vec_res) { // 栈 stack\u0026lt;TreeNode *\u0026gt; st; // 中序遍历 左根右 // 要一直访问到最左边的叶子节点, 此时要一直存储到栈里 // cur为叶子节点进入到下一次循环后, 会为空, 进入else分支, // 此时开始栈开始弹出指针, 加入其值到数组中,即左 // 栈弹出的节点即为最左的叶子节点,此时复制 // 退出循环条件 当前节点为空且栈为空 TreeNode *cur = node; // 大致写出来了, 但是对于这个处理中序的逻辑还是想不出来, // 只是知道这样的结果是中序, 但是不知道为什么这样做, 或则说, // 我们怎么从一开始设计这个算法 while (cur != nullptr || !st.empty()) { if (cur != nullptr) { st.push(cur); cur = cur-\u0026gt;left; } else { cur = st.top(); st.pop(); vec_res.push_back(cur-\u0026gt;val); cur = cur-\u0026gt;right; // 加入右节点, 这里其实重复了, 下次进入循环也有这个if过程 // if(cur !=nullptr){ // st.push(cur); // } } } } int main() { // 创建节点 TreeNode *root = new TreeNode(3); TreeNode *node9 = new TreeNode(9); TreeNode *node20 = new TreeNode(20); TreeNode *node15 = new TreeNode(15); TreeNode *node7 = new TreeNode(7); // 构建树的结构 // 3 // | \\ // 9 20 // / \\ // 15 7 root-\u0026gt;left = node9; root-\u0026gt;right = node20; node20-\u0026gt;left = node15; node20-\u0026gt;right = node7; // 非递归前序遍历 vector\u0026lt;int\u0026gt; pre_result; preordered_traversal(root, pre_result); cout \u0026lt;\u0026lt; \u0026#34;非递归前序遍历: \u0026#34;; for (auto i : pre_result) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; // 非递归后序遍历 vector\u0026lt;int\u0026gt; post_result; postorder_traversal(root, post_result); cout \u0026lt;\u0026lt; \u0026#34;非递归后序遍历: \u0026#34;; for (auto i : post_result) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; // 非递归中序遍历 vector\u0026lt;int\u0026gt; in_result; inorder_traversal(root, in_result); cout \u0026lt;\u0026lt; \u0026#34;非递归中序遍历: \u0026#34;; for (auto i : in_result) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; // 删除节点 delete root; delete node9; delete node20; delete node15; delete node7; return 0; } 3_二叉树的层序遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; void levelorder_traversal(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;vec_res) { if (node == nullptr) { return; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(node); while (!que.empty()) { TreeNode *cur = que.front(); que.pop(); vec_res.push_back(cur-\u0026gt;val); if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } } int main() { // 创建节点 TreeNode *root = new TreeNode(3); TreeNode *node9 = new TreeNode(9); TreeNode *node20 = new TreeNode(20); TreeNode *node15 = new TreeNode(15); TreeNode *node7 = new TreeNode(7); // 构建树的结构 // 3 // | \\ // 9 20 // / \\ // 15 7 root-\u0026gt;left = node9; root-\u0026gt;right = node20; node20-\u0026gt;left = node15; node20-\u0026gt;right = node7; // 层次遍历 vector\u0026lt;int\u0026gt; level_res; levelorder_traversal(root, level_res); cout \u0026lt;\u0026lt; \u0026#34;层次遍历: \u0026#34;; for (auto i : level_res) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; // 删除节点 delete root; delete node9; delete node20; delete node15; delete node7; return 0; } 10个练习题 1_二叉树的层序遍历_leetcode_102 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: void levelorder_traversal(TreeNode *root, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res) { if (root == nullptr) { return; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); vector\u0026lt;int\u0026gt; temp; for (int i = 0; i \u0026lt; size; i++) { TreeNode *cur = que.front(); que.pop(); temp.push_back(cur-\u0026gt;val); if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } res.push_back(temp); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; levelorder_traversal(root, res); return res; } }; 2_二叉树的层序遍历II_leetcode_107 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: void levelorder_traversal(TreeNode *root, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;res) { if (root == nullptr) { return; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); vector\u0026lt;int\u0026gt; temp; for (int i = 0; i \u0026lt; size; i++) { TreeNode *cur = que.front(); que.pop(); temp.push_back(cur-\u0026gt;val); if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } res.push_back(temp); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrderBottom(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; levelorder_traversal(root, res); reverse(res.begin(), res.end()); return res; } }; 3_二叉树的右视图_leetcode_199 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: void levelorder_traversal(TreeNode *root, vector\u0026lt;int\u0026gt; \u0026amp;res) { if (root == nullptr) { return; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); for (int i = 0; i \u0026lt; size; i++) { TreeNode *cur = que.front(); que.pop(); if (i == size - 1) { res.push_back(cur-\u0026gt;val); } if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } } } vector\u0026lt;int\u0026gt; rightSideView(TreeNode *root) { vector\u0026lt;int\u0026gt; res; levelorder_traversal(root, res); return res; } }; 4_二叉树的层平均值_leetcode_637 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: void levelorder_traversal(TreeNode *root, vector\u0026lt;double\u0026gt; \u0026amp;res) { if (root == nullptr) { return; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); double sum = 0; int i; for (i = 0; i \u0026lt; size; i++) { TreeNode *cur = que.front(); que.pop(); sum += (double)cur-\u0026gt;val; if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } res.push_back(sum / i); } } vector\u0026lt;double\u0026gt; averageOfLevels(TreeNode *root) { vector\u0026lt;double\u0026gt; res; levelorder_traversal(root, res); return res; } }; 5_N叉树的层序遍历_leetcode_429 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Node { public: int val; vector\u0026lt;Node *\u0026gt; children; Node() {} Node(int _val) { val = _val; } Node(int _val, vector\u0026lt;Node *\u0026gt; _children) { val = _val; children = _children; } }; class Solution { public: void levelorder_traversal(Node *root, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;vec_res) { if (root == nullptr) { return; } queue\u0026lt;Node *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); Node *cur; vector\u0026lt;int\u0026gt; temp; // 遍历每一层 for (int i = 0; i \u0026lt; size; i++) { cur = que.front(); que.pop(); temp.push_back(cur-\u0026gt;val); // 加入它的孩子, 孩子是有顺序的, 从左到右, int child_count = cur-\u0026gt;children.size(); // 剪枝 if (child_count == 0) { continue; } for(int j=0;j\u0026lt;child_count;j++){ if (cur-\u0026gt;children[j] == nullptr) { continue; } else { que.push(cur-\u0026gt;children[j]); } } } vec_res.push_back(temp); } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(Node *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec_res; levelorder_traversal(root, vec_res); return vec_res; } }; 6_在每个树行中找最大值_leetcode_515 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: void levelorder_traversal(TreeNode *root, vector\u0026lt;int\u0026gt; \u0026amp;vec_res) { if (root == nullptr) { return; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); TreeNode *cur; int max; // max 初始化为每一层的第一个元素的值 for (int i = 0; i \u0026lt; size; i++) { cur = que.front(); que.pop(); if (i == 0) { max = cur-\u0026gt;val; } if (max \u0026lt; cur-\u0026gt;val) { max = cur-\u0026gt;val; } if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } vec_res.push_back(max); } } vector\u0026lt;int\u0026gt; largestValues(TreeNode *root) { vector\u0026lt;int\u0026gt; vec_res; levelorder_traversal(root, vec_res); return vec_res; } }; 7_填充每个节点的下一个右侧节点指针_leetcode_116 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Node { public: int val; Node *left; Node *right; Node *next; Node() : val(0), left(nullptr), right(nullptr), next(nullptr) {} Node(int _val) : val(_val), left(nullptr), right(nullptr), next(nullptr) {} Node(int _val, Node *_left, Node *_right, Node *_next) : val(_val), left(_left), right(_right), next(_next) {} }; class Solution { public: void levelorder_traversal_v2(Node *root) { if (root == nullptr) { return; } queue\u0026lt;Node *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); Node *cur; // i不是该层的最后一个, 都指向下一个节点 // i是该层的最后一个, 指向空节点, 默认值是空, 不需要额外指定 for (int i = 0; i \u0026lt; size; i++) { cur = que.front(); que.pop(); if (i \u0026lt; size - 1) { cur-\u0026gt;next = que.front(); } if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } } } // 思路层序遍历, 每一层的的节点指针都加入数组, 指针数组保存到二维数组中 // 最后对数组进行遍历, 处理每一层 // 这么做的原因: 不是在层序遍历中处理, // 是因为层序遍历中无法知道同一层的后续节点, 要想知道就必须弹出后续节点, // 但这就做不到层序遍历 // 不需要返回值, 修改头指针即可 void levelorder_traversal(Node *\u0026amp;root) { if (root == nullptr) { return; } vector\u0026lt;vector\u0026lt;Node *\u0026gt;\u0026gt; vec_res; queue\u0026lt;Node *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); Node *cur; vector\u0026lt;Node *\u0026gt; temp; for (int i = 0; i \u0026lt; size; i++) { cur = que.front(); que.pop(); temp.push_back(cur); if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } vec_res.push_back(temp); } // vec_res存放每一层, 从左到右的指针 for (int i = 0; i \u0026lt; vec_res.size(); i++) { // 遍历每一层的指针 vec_res[i][j] // 至少有1个元素, 每一个指针的next指向下一个 // 如果下一个超出了索引size-1, 则指向空, 也就是 j+1 = // vec_res[i].size() for (int j = 0; j \u0026lt; vec_res[i].size(); j++) { if (j == vec_res[i].size() - 1) { vec_res[i][j]-\u0026gt;next = nullptr; } else { vec_res[i][j]-\u0026gt;next = vec_res[i][j + 1]; } } } } Node *connect(Node *root) { levelorder_traversal(root); return root; } }; 8_填充每个节点的下一个右侧节点指针II_leetcode_117 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;queue\u0026gt; using namespace std; class Node { public: int val; Node *left; Node *right; Node *next; Node() : val(0), left(nullptr), right(nullptr), next(nullptr) {} Node(int _val) : val(_val), left(nullptr), right(nullptr), next(nullptr) {} Node(int _val, Node *_left, Node *_right, Node *_next) : val(_val), left(_left), right(_right), next(_next) {} }; class Solution { public: void levelorder_traversal_v2(Node *root) { if (root == nullptr) { return; } queue\u0026lt;Node *\u0026gt; que; que.push(root); while (!que.empty()) { int size = que.size(); Node *cur; // i不是该层的最后一个, 都指向下一个节点 // i是该层的最后一个, 指向空节点, 默认值是空, 不需要额外指定 for (int i = 0; i \u0026lt; size; i++) { cur = que.front(); que.pop(); if (i \u0026lt; size - 1) { cur-\u0026gt;next = que.front(); } if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } } } Node *connect(Node *root) { levelorder_traversal_v2(root); return root; } }; 9_二叉树的最大深度_leetcode_104 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: int maxDepth(TreeNode *root) { if (root == nullptr) { return 0; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); int depth = 0; while (!que.empty()) { int size = que.size(); TreeNode *cur; for (int i = 0; i \u0026lt; size; i++) { cur = que.front(); que.pop(); if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } depth++; } return depth; } }; 10_二叉树的最小深度_leetcode_111 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;queue\u0026gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: // 最优解法是去掉for和while的break,for原来的break用return depth+1代替即可 int minDepth(TreeNode *root) { if (root == nullptr) { return 0; } queue\u0026lt;TreeNode *\u0026gt; que; que.push(root); int depth = 0; while (!que.empty()) { int size = que.size(); TreeNode *cur; for (int i = 0; i \u0026lt; size; i++) { cur = que.front(); que.pop(); if (cur-\u0026gt;left == nullptr \u0026amp;\u0026amp; cur-\u0026gt;right == nullptr) { break; } if (cur-\u0026gt;left != nullptr) { que.push(cur-\u0026gt;left); } if (cur-\u0026gt;right != nullptr) { que.push(cur-\u0026gt;right); } } depth++; if (cur-\u0026gt;left == nullptr \u0026amp;\u0026amp; cur-\u0026gt;right == nullptr) { break; } } return depth; } }; ","date":"2025-05-30T20:48:03+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day13/","title":"代码随想录_day13"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n5_逆波兰表达式求值_leetcode_150 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: int evalRPN(vector\u0026lt;string\u0026gt; \u0026amp;tokens) { stack\u0026lt;int\u0026gt; stack_eval; for (int i = 0; i \u0026lt; tokens.size(); i++) { // 符号, 栈中取出两个元素, 进行运算, 加入到stack_eval if (tokens[i] == \u0026#34;+\u0026#34; || tokens[i] == \u0026#34;-\u0026#34; || tokens[i] == \u0026#34;*\u0026#34; || tokens[i] == \u0026#34;/\u0026#34;) { int res; int num2 = stack_eval.top(); stack_eval.pop(); int num1 = stack_eval.top(); stack_eval.pop(); if (tokens[i] == \u0026#34;+\u0026#34;) { res = num1 + num2; } if (tokens[i] == \u0026#34;-\u0026#34;) { res = num1 - num2; } if (tokens[i] == \u0026#34;*\u0026#34;) { res = num1 * num2; } if (tokens[i] == \u0026#34;/\u0026#34;) { res = num1 / num2; } stack_eval.push(res); } // 数字, 加入栈 else { stack_eval.push(stoi(tokens[i])); } } return stack_eval.top(); } }; 6_滑动窗口最大值_leetcode_239 滑动窗口主循环的终止条件错误：\n原始条件： for (int i = 1; i + k \u0026lt; nums.size() - 1; i++)\n问题： 这个条件导致循环提前结束。它未能处理到数组中的最后一个滑动窗口。\n正确理解： 当 i 作为滑动窗口的起始索引时，它应该从1（第二个窗口的起始）一直迭代到 nums.size() - k（最后一个窗口的起始）。\n正确的条件： for (int i = 1; i \u0026lt;= nums.size() - k; i++)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;deque\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 构造一个单调队列, class Solution { private: deque\u0026lt;int\u0026gt; deque_k; // pop函数, 如果出口处的值和val相等, 则弹出 void pop_k(int val) { if (!deque_k.empty() \u0026amp;\u0026amp; val == deque_k.front()) { deque_k.pop_front(); } } // push函数, 要弹出比val小的元素, 然后加入val void push_k(int val) { // 弹出比val小的元素 while (!deque_k.empty() \u0026amp;\u0026amp; deque_k.back() \u0026lt; val) { deque_k.pop_back(); } deque_k.push_back(val); } // get_max_value int get_max_value() { return deque_k.front(); } public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { vector\u0026lt;int\u0026gt; vec_res; // 剪枝 if (nums.size() \u0026lt; k) { return vec_res; } // 循环最好先初始化 for (int i = 0; i \u0026lt; k; i++) { push_k(nums[i]); } vec_res.push_back(get_max_value()); for (int i = 1; i \u0026lt;= nums.size() - k; i++) { pop_k(nums[i - 1]); push_k(nums[i + k - 1]); vec_res.push_back(get_max_value()); } return vec_res; } }; 7_前k个高频元素_leetcode_347 1. 算法核心与时间复杂度 问题核心思路： 使用 std::unordered_map\u0026lt;int, int\u0026gt; 来统计每个数字的出现频率（键是数字，值是频率）。 利用一个大小为 k 的小顶堆（Min-Heap） 来存储当前频率最高的 k 个元素。 算法流程： 遍历输入数组 nums，填充 unordered_map。 遍历 unordered_map 中的每个键值对（数字-频率）。 将键值对 push 入小顶堆。 如果小顶堆的大小超过 k，则 pop 掉堆顶元素。由于是小顶堆，被弹出的将是当前堆中频率最小的那个元素。 最终，堆中剩下的 k 个元素就是频率最高的 k 个。 将堆中的元素按正确顺序（通常是倒序弹出）放入结果 vector。 时间复杂度分析： 统计频率：$O(N)$，其中 $N$ 是 nums 的长度。 遍历 map 并维护堆：$O(M \\log K)$，其中 $M$ 是 map 中不重复元素的数量（最坏情况下 $M=N$）。每次 push 和 pop 操作都是 $O(\\log K)$。 收集结果：$O(K \\log K)$（因为要弹出 K 次）。 总时间复杂度：$O(N + M \\log K + K \\log K)$，简化为 $O(N \\log K)$。这是该问题的最优解法。 2. 小顶堆的实现与定制化 C++ 小顶堆的实现：\n是的，在 C++ STL 中，小顶堆通过 std::priority_queue 来实现。 std::priority_queue 默认是大顶堆。要实现小顶堆，需要为其提供一个自定义的比较器（Comparator）。 std::priority_queue 的模板参数：\nstd::priority_queue\u0026lt;T, Container, Compare\u0026gt; T：堆中存储的元素类型。在本题中是 std::pair\u0026lt;int, int\u0026gt;（数字-频率对）。 Container：实际存储元素的底层容器类型，通常是 std::vector\u0026lt;T\u0026gt;。 Compare：定义元素优先级的函数对象（Functor）的类型。这是实现小顶堆的关键。 自定义比较器 mycomparison（或 cmp 类）：\n这是一个类，它重载了函数调用运算符 operator()。 作用： 它让 mycomparison 的实例（对象）能够像函数一样被调用，从而作为 std::priority_queue 的比较规则。 访问修饰符： operator() 必须是 public 的，否则 std::priority_queue 无法调用它。 比较逻辑： bool operator()(const pair\u0026lt;int, int\u0026gt; \u0026amp;lhs, const pair\u0026lt;int, int\u0026gt; \u0026amp;rhs) 其返回值为 true 表示 lhs 的优先级低于 rhs（即 lhs 应该排在 rhs 之后）。 要实现小顶堆（希望频率小的元素优先级高），比较逻辑是 return lhs.second \u0026gt; rhs.second;。这意味着如果 lhs 的频率大于 rhs 的频率，那么 lhs 的优先级就低，它会被放到堆的下方。 operator() 中 lhs 和 rhs 的含义：\nlhs (left-hand side) 和 rhs (right-hand side) 是比较函数中约定俗成的参数命名，代表任意两个待比较的元素。 它们不固定代表堆操作中的特定元素（如即将加入的或堆顶元素）。std::priority_queue 内部的堆算法在调整过程中，会把需要比较的元素作为 lhs 和 rhs 传入。 const \u0026amp; 参数的作用：\nconst pair\u0026lt;int, int\u0026gt;\u0026amp; lhs 中的 \u0026amp; 是引用，用于避免复制 pair 对象的开销，提高性能，因为比较器会被频繁调用。 const 确保函数内部不会修改传入的参数。 3. 相关 C++ 语言特性 std::pair 数据结构： 它是一个简单的模板类，用于精确组合两个（且只能是两个） 值（如数字和频率）。成员通过 .first 和 .second 访问。 如果需要组合多于两个元素： 推荐使用 std::tuple (C++11+)，它可以组合任意数量的不同类型的值。 或者定义自定义 struct 或 class，当数据有明确语义时更佳。 operator() 重载的本质： 它让类的实例（对象）可以像函数一样被调用。 在 C++98/03 中，定义重载 operator() 的类是为 std::priority_queue 提供自定义比较器的主要方式，因为其模板参数需要一个类型。C++11 后的 Lambda 表达式也基于函数对象实现。 比较器的作用就是改变 std::priority_queue 的默认排序行为（从大顶堆到小顶堆）。 4. 代码细节问题与修正 结果 vector 初始化： 原问题： vector\u0026lt;int\u0026gt; vec_res; 后直接使用 vec_res[i] = ...; 导致越界访问。 修正： 需要将 vector 初始化为所需大小，例如 vector\u0026lt;int\u0026gt; vec_res(k);，再进行倒序填充。 cmp::operator() 访问修饰符： 原问题： private: bool operator()... 修正： 必须是 public，否则外部无法调用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;queue\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { private: // 定义小顶堆的cmp类 class cmp { public: bool operator()(const pair\u0026lt;int, int\u0026gt; \u0026amp;lhs, const pair\u0026lt;int, int\u0026gt; \u0026amp;rhs) { return lhs.second \u0026gt; rhs.second; // rhs是后加进来的元素, 为了让小的优先级大, 也就是让大于成立 } }; public: vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { // 用map统计数字出现的次数 数字:频率 // 时间复杂度 o(n) unordered_map\u0026lt;int, int\u0026gt; map_res; for (int i = 0; i \u0026lt; nums.size(); i++) { map_res[nums[i]]++; } // 定义小顶堆 priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp\u0026gt; queue_res; // 遍历map, 元素加入小顶堆, 大于k个弹出 // 小顶堆排序的复杂度o(logk) // 总时间复杂度o(nlogk) for (auto i : map_res) { queue_res.push(i); if (queue_res.size() \u0026gt; k) { queue_res.pop(); } } // 时间复杂度o(k) // 最初构造数组, 倒序加入, 毎加入一次就弹出 vector\u0026lt;int\u0026gt; vec_res(k); for (int i = k - 1; i \u0026gt;= 0; i--) { vec_res[i] = queue_res.top().first; queue_res.pop(); } return vec_res; // 最后的时间复杂度 o(nlogk) } }; ","date":"2025-05-28T15:02:56+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day11/","title":"代码随想录_day11"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n1_用栈实现队列_leetcode_232 你说的“out栈前面加入了元素，实际上in后面加入了元素，不用着急马上加入到out栈，等out栈元素空了再一起加入，这样可以保证先进先出”这个描述非常准确地概括了核心优化逻辑。 没错，关键就在于：\npush 操作只管往 stack_in 里塞。 这代表着新来的元素，它们暂时不用关心出队顺序。\npop 或 peek 操作的延迟倒腾： 只有当 stack_out 已经空了，无法再提供队头元素时，我们才一次性地把 stack_in 中的所有元素“倒”到 stack_out。\n这个“倒腾”过程非常巧妙：由于栈是后进先出，stack_in 中最底部的元素（最早进入的）在倒腾后会变成 stack_out 的顶部元素（最先出队的）。\n一旦 stack_out 有了元素，后续的 pop 和 peek 都会优先从 stack_out 获取，直到 stack_out 再次为空。\n为什么这样做是高效的？\n因为它避免了每次 push 或 pop 都进行倒腾操作。每个元素只会经历一次从 stack_in 到 stack_out 的移动，这使得整个序列操作的平均时间复杂度达到了 O(1)。\n虽然单次倒腾可能需要 O(N) 的时间（N 是 stack_in 的元素数量），但由于每个元素只移动一次，所以分摊下来，每次操作的成本是很低的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;stack\u0026gt; using namespace std; class MyQueue { private: stack\u0026lt;int\u0026gt; stack_in; stack\u0026lt;int\u0026gt; stack_out; void transfer_elements_if_needed() { if (stack_out.empty()) { while (!stack_in.empty()) { stack_out.push(stack_in.top()); stack_in.pop(); } } } public: // 构造函数 MyQueue() {} // 用栈实现队列 // 1.元素push进入stack_in void push(int x) { stack_in.push(x); } // 弹出元素, 每次弹出的时候, stack_in要清空 // 1.如果stack_out为空, 将stack_in元素全部弹出,加入到stack_out // 2.stack_out非空的情况下, 弹出 int pop() { transfer_elements_if_needed(); int result = stack_out.top(); stack_out.pop(); return result; } // 确保stack_out有元素可以看, 返回队列开头的元素, int peek() { transfer_elements_if_needed(); return stack_out.top(); } // stack_in 和 stack_out同时为空时, 返回为true bool empty() { return stack_in.empty() \u0026amp;\u0026amp; stack_out.empty(); } }; 2_用队列实现栈_leetcode_225 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;queue\u0026gt; using namespace std; class MyStack { queue\u0026lt;int\u0026gt; queue_stack; public: MyStack() { } void push(int x) { queue_stack.push(x); } // 弹出栈的元素, 用queue实现 // 1.弹出queue的size-1个元素, 再push进去 // 2.弹出元素 int pop() { int size = queue_stack.size(); size--; while(size--){ int temp = queue_stack.front(); queue_stack.pop(); queue_stack.push(temp); } int res = queue_stack.front(); queue_stack.pop(); return res; } int top() { return queue_stack.back(); } bool empty() { return queue_stack.empty(); } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-\u0026gt;push(x); * int param_2 = obj-\u0026gt;pop(); * int param_3 = obj-\u0026gt;top(); * bool param_4 = obj-\u0026gt;empty(); */ 3_有效的括号_leetcode_20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: bool isValid_v2(string s) { stack\u0026lt;char\u0026gt; stack_char; // 1.剪枝 if (s.size() % 2 != 0) { return false; } for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39;(\u0026#39;) { stack_char.push(\u0026#39;)\u0026#39;); } else if (s[i] == \u0026#39;{\u0026#39;) { stack_char.push(\u0026#39;}\u0026#39;); } else if (s[i] == \u0026#39;[\u0026#39;) { stack_char.push(\u0026#39;]\u0026#39;); } // 处理右括号 else { // 栈为空 if (stack_char.empty()) { return false; } // 栈非空 else if (s[i] == stack_char.top()) { stack_char.pop(); } else if (s[i] != stack_char.top()) { return false; } } } // 循环结束后, 如果栈非空, 返回false return stack_char.empty(); } bool isValid(string s) { stack\u0026lt;char\u0026gt; stack_char; // 1.剪枝 if (s.size() % 2 != 0) { return false; } for (int i = 0; i \u0026lt; s.size(); i++) { if (s[i] == \u0026#39;(\u0026#39;) { stack_char.push(\u0026#39;)\u0026#39;); } else if (s[i] == \u0026#39;{\u0026#39;) { stack_char.push(\u0026#39;}\u0026#39;); } else if (s[i] == \u0026#39;[\u0026#39;) { stack_char.push(\u0026#39;]\u0026#39;); } // 右括号, 情况1 栈顶的符号相同 else if (!stack_char.empty() \u0026amp;\u0026amp; s[i] == stack_char.top()) { stack_char.pop(); } // 右括号, 情况2 栈顶的符号不相同 else if (!stack_char.empty() \u0026amp;\u0026amp; s[i] != stack_char.top()) { return false; } // 栈为空 else if (stack_char.empty()) { return false; } } // 循环结束后, 如果栈非空, 返回false return stack_char.empty(); } }; 4_删除字符串中的所有相邻重复项_leetcode_1047 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: string removeDuplicates_v2(string s) { // 利用字符串作为栈 string stack_char; // 通过字符栈可以达到删除的目的, 关键是如何顺序输出 for (int i = 0; i \u0026lt; s.size(); i++) { // 字符栈为空 if (stack_char.empty()) { stack_char.push_back(s[i]); } // 字符栈非空 else { if (s[i] != stack_char.back()) { stack_char.push_back(s[i]); } else { stack_char.pop_back(); } } } return stack_char; } string removeDuplicates_v1(string s) { stack\u0026lt;char\u0026gt; stack_char; // 通过字符栈可以达到删除的目的, 关键是如何顺序输出 for (int i = 0; i \u0026lt; s.size(); i++) { // 字符栈为空 if (stack_char.empty()) { stack_char.push(s[i]); } // 字符栈非空 else { if (s[i] != stack_char.top()) { stack_char.push(s[i]); } else { stack_char.pop(); } } } string result = \u0026#34;\u0026#34;; while (!stack_char.empty()) { result += stack_char.top(); stack_char.pop(); } reverse(result.begin(), result.end()); return result; } }; ","date":"2025-05-27T15:08:36+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day10/","title":"代码随想录_day10"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n4_翻转字符串里的单词_leetcode_151 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: string reverseWords(string s) { // 1.去除空格 int slow, fast; for (slow = fast = 0; fast \u0026lt; s.size(); fast++) { // fast遇到的不是空格, 也就是我们要加入新数组中的元素 // 除了第一个单词, 其余单词的首字母前面都要加个空格 if (s[fast] != \u0026#39; \u0026#39;) { // 处理首字母 // slow==0, 意味着此时加入的是第1个单词 if (slow == 0) { s[slow++] = s[fast++]; } // slow !=0 else { s[slow++] = \u0026#39; \u0026#39;; } // 处理该单词剩余的字母, 这里主要fast不要超出s.size() while (fast \u0026lt; s.size() \u0026amp;\u0026amp; s[fast] != \u0026#39; \u0026#39;) { s[slow++] = s[fast++]; } } } // slow是新字符串的长度 s.resize(slow); // 反转整个字符串, 再反转每个不含空格的子串 // 2.反转整个字符串 reverse(s.begin(), s.end()); // 现在是反转空格隔开的子串 int begin = 0; // 3.反转子串 for (int i = 0; i \u0026lt; s.size(); i++) { // 最后一个单词后面没有空格 if (s[i] == \u0026#39; \u0026#39;) { reverse(s.begin() + begin, s.begin() + i); begin = i + 1; // 反转后更新字符串的起始点 } if (i == s.size() - 1) { reverse(s.begin() + begin, s.end()); } } return s; } }; int main() { string s = \u0026#34; the sky is blue! \u0026#34;; Solution sol; string s_res = sol.reverseWords(s); cout \u0026lt;\u0026lt; s_res \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 5_右旋字符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); int k; string s; cin \u0026gt;\u0026gt; k; cin \u0026gt;\u0026gt; s; reverse(s.begin(), s.end()); reverse(s.begin(), s.begin() + k); reverse(s.begin() + k, s.end()); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 6_实现strStr_leetcode_28 非常重要 1. KMP 算法的核心思想 目标： 在主串 haystack 中查找模式串 needle 的第一次出现位置。 朴素算法的低效： 当模式串失配时，朴素算法会同时回溯主串和模式串指针，导致重复比较。 KMP 的优化： 在失配时，不回溯主串指针 i。 仅仅根据模式串自身的结构信息（通过 next 数组），高效地回溯模式串指针 j，让模式串在主串上“滑动”，避免重复比较，从而实现线性的时间复杂度。 2. next 数组 (LPS 数组) 的构建 (get_next 函数) next 数组是 KMP 算法的“灵魂”，它存储了模式串自身的匹配信息，用于指导失配时的回溯。\n真前缀 (Proper Prefix) 与 真后缀 (Proper Suffix) 的含义：\n真前缀： 指一个字符串不包括其自身的所有前缀。 例如，对于字符串 \u0026quot;abc\u0026quot;： 前缀有：\u0026quot;\u0026quot; (空字符串), \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot;, \u0026quot;abc\u0026quot; 真前缀有：\u0026quot;\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot; 真后缀： 指一个字符串不包括其自身的所有后缀。 例如，对于字符串 \u0026quot;abc\u0026quot;： 后缀有：\u0026quot;\u0026quot; (空字符串), \u0026quot;c\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;abc\u0026quot; 真后缀有：\u0026quot;\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;bc\u0026quot; next[i] 的精确含义：\nnext[i] 表示模式串 needle 中，以 i 为结尾字符的前缀子串 needle[0...i]，它最长相等真前缀和真后缀的长度。 示例： 对于 needle = \u0026quot;ababa\u0026quot;： next[0] (for \u0026quot;a\u0026quot;) = 0 next[1] (for \u0026quot;ab\u0026quot;) = 0 next[2] (for \u0026quot;aba\u0026quot;) = 1 (因为 \u0026quot;a\u0026quot; 是 \u0026quot;aba\u0026quot; 最长相等的真前缀和真后缀) next[3] (for \u0026quot;abab\u0026quot;) = 2 (因为 \u0026quot;ab\u0026quot; 是 \u0026quot;abab\u0026quot; 最长相等的真前缀和真后缀) next[4] (for \u0026quot;ababa\u0026quot;) = 3 (因为 \u0026quot;aba\u0026quot; 是 \u0026quot;ababa\u0026quot; 最长相等的真前缀和真后缀) 所以 next 数组是 [0, 0, 1, 2, 3]。 区分： 我们也讨论了 KMP next 数组存在多种定义（如标准 LPS 数组与优化 nextval），但核心思想一致，且要求在构建和匹配阶段保持一致性。在 LeetCode 和大多数竞赛中，标准 LPS 数组是主流。 get_next 函数的核心逻辑：\n初始化： next[0] = 0; (长度为1的前缀没有公共前后缀)。j = 0; (j 初始代表长度为0的空前缀)。 for (int i = 1; i \u0026lt; n; ++i)： i 遍历模式串，next[i] 的值依赖于 needle[0...i-1] 的信息。 j 的双重身份（长度与索引）： j 的值代表当前已找到的最长公共前后缀的长度。 j 的值也作为索引，指向模式串中，这个最长公共前后缀之后的那个字符 (needle[j])，它是我们用来与 needle[i] 比较的字符。 while (j \u0026gt; 0 \u0026amp;\u0026amp; needle[i] != needle[j]) { j = next[j - 1]; } (回溯 j - 关键)： 时机： 当 needle[i] (当前后缀字符) 与 needle[j] (当前前缀字符) 不匹配，且 j 大于 0 (还有更短的公共前后缀可以回溯) 时。 作用： 将 j 回溯到 next[j-1] 的位置。next[j-1] 存储的是 needle[0...j-1] 这个前缀的次长公共前后缀的长度。这个 while 循环会持续回溯，直到 j 归零，或找到一个可以匹配 needle[i] 的 needle[j]。 意义： 这种回溯是有策略的，它利用了模式串自身的重复结构，避免了盲目回溯到 0。 if (needle[i] == needle[j]) { j++; } (匹配扩展)： 时机： 当 needle[i] 和回溯后的 needle[j] 匹配时。 作用： j++，表示最长公共前后缀的长度增加了 1。这个新长度 j 将是 next[i] 的值。 next[i] = j;： 存储本轮计算出的 j 值。 3. KMP 匹配过程 (strStr 函数) 在构建完 next 数组后，KMP 匹配过程本身相对直观，也使用了类似的双指针和回溯逻辑。\n初始化： i = 0 (主串指针)，j = 0 (模式串指针/已匹配长度)。 主循环： for (int i = 0; i \u0026lt; haystack.size(); i++)。 while (j \u0026gt; 0 \u0026amp;\u0026amp; haystack[i] != needle[j]) { j = next[j - 1]; } (失配回溯)： 时机： 当 haystack[i] (主串当前字符) 与 needle[j] (模式串当前字符) 不匹配，且 j \u0026gt; 0 时。 作用： j 回溯到 next[j-1]。这意味着我们利用了 needle[0...j-1] 这段已匹配部分的最长公共前后缀，将模式串向前滑动，让 needle[next[j-1]] 对齐 haystack[i]，避免了 i 的回溯。 if (haystack[i] == needle[j]) { j++; } (匹配前进)： 时机： 当 haystack[i] 和 needle[j] 匹配时。 作用： j++，表示模式串又成功匹配了一个字符。 匹配成功条件： if (j == needle.size()) { return i - needle.size() + 1; } 判断： 当 j 的值达到模式串的完整长度 (needle.size()) 时，表示整个模式串已经匹配成功。 返回： 匹配的起始索引是 i - needle.size() + 1。 未找到： 循环结束后，如果 j 未达到 needle.size()，返回 -1。 空模式串： if (needle.empty()) { return 0; } (特殊处理，通常返回 0)。 4. KMP 的核心原理：j 维护的不变式 KMP 算法的精妙之处在于 j 变量在 get_next 函数中维护的一个关键循环不变量。\nj 维护的不变式：\n在 get_next 函数中，当 for 循环推进到 i 索引时，j 的值（在进入 while 循环并可能回溯之后，但在 if 匹配检查之前）始终代表着：\nneedle[0...j-1] (模式串的一个前缀) 已经和 needle[i-j...i-1] (模式串中以 i-1 结尾的一个后缀) 完全匹配。\n也就是说，此时 j 是模式串 needle[0...i-1] 这个前缀的最长公共前后缀的长度。\n为什么 needle[i] == needle[j] 意味着可以扩充长度？\n现在，我们来看当 needle[i] == needle[j] 发生时：\n我们知道：\nneedle[0...j-1] == needle[i-j...i-1] （这是 j 的定义所保证的，即它是一个公共前后缀）\nneedle[j] == needle[i] （这是当前的匹配条件）\n通过这两点，我们可以推导出：\nneedle[0...j-1] 后面接上 needle[j]\n等价于\nneedle[i-j...i-1] 后面接上 needle[i]\n也就是说：\nneedle[0...j] == needle[i-j...i]\n这意味着什么？\nneedle[0...j] 是模式串 needle[0...i] 的一个真前缀。\nneedle[i-j...i] 是模式串 needle[0...i] 的一个真后缀。\n而且，这两个真前缀和真后缀是相等的，并且它们的长度是 j+1。\n既然 j 已经代表了 needle[0...i-1] 的最长公共前后缀的长度，并且我们现在能通过 needle[i] 和 needle[j] 的匹配将其扩展一位，那么 j+1 就必然是 needle[0...i] 的最长公共前后缀的长度。\n正是对这些循环不变量的维护，使得 KMP 算法能够以其独特的“模式串滑动”方式，在 $O(N+M)$ 的时间复杂度内完成字符串匹配，这比朴素算法的 $O(NM)$ 具有显著的性能优势。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 本题的难点是实现 KMP 算法, KMP的难点是求出模式串的next数组 class Solution { public: vector\u0026lt;int\u0026gt; get_next(const string \u0026amp;needle) { int n = needle.size(); vector\u0026lt;int\u0026gt; next(n); next[0] = 0; int j = 0; for (int i = 1; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; needle[j] != needle[i]) { j = next[j - 1]; } if (needle[i] == needle[j]) { j++; } next[i] = j; } return next; } int strStr(string haystack, string needle) { if (needle.empty()) { return 0; } vector\u0026lt;int\u0026gt; next = get_next(needle); int j = 0; for (int i = 0; i \u0026lt; haystack.size(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; needle[j] != haystack[i]) { j = next[j - 1]; } if (needle[j] == haystack[i]) { j++; } // 理解j的值, 还是从循环开始去对应 // 比如i=0时, 匹配成功j对应的是1, 即是匹配的子串长度, // 所以这里的j即表示长度 if (j == needle.size()) { // 最后要返回在在haystack中的索引, 最初的索引 return i - j + 1; } } return -1; } }; 7_重复的子字符串_leetcode_459 非常重要 这个问题要求我们判断一个非空字符串 s 是否能由它的一个子串重复多次拼接而成。解决这个问题的核心在于巧妙地运用 KMP 算法中计算出的 next 数组。\n1. 问题核心思路：利用 next 数组的最后一位 计算 next 数组： 我们首先需要为字符串 s 计算出其 next 数组。next[i] 表示 s 中以索引 i 结尾的前缀子串 s[0...i] 的最长相等真前缀和真后缀的长度。 关注 next[n-1]： 字符串 s 的长度是 n。next[n-1]（我们称之为 L）代表了整个字符串 s 的最长相等真前缀和真后缀的长度。 2. 关键数学原理：n - L 是最小重复单元的长度 这是理解问题的最核心部分，也是我们这次讨论的重点：\nL 的意义： 如果一个字符串 s 能由一个子串 sub 重复 k 次构成，那么 s 的最长相等真前缀（即 (k-1) 个 sub 的拼接）将与它的最长相等真后缀（同样是 (k-1) 个 sub 的拼接）相等。这个最长公共前后缀的长度 L 就等于 n - len_sub，其中 len_sub 是 sub 的长度。 推导 n - L： 通过 n = k * len_sub 和 L = (k-1) * len_sub，我们可以推导出 n - L = len_sub。 结论： 因此，n - L 精确地代表了构成字符串 s 的最小重复单元的长度。 3. 完整的判断条件 要判断字符串 s 是否由重复子串构成，需要同时满足以下两个条件：\nL \u0026gt; 0：\n这个条件确保字符串 s 必须拥有一个非空的公共前后缀。如果 L=0，意味着 s 不具备任何能构成重复模式的内部结构（例如 abcde）。 此外，L \u0026gt; 0 还保证了 n - L \u0026lt; n，即最小重复单元的长度小于字符串的总长度。这就意味着 s 是由这个最小重复单元重复了多于一次（k \u0026gt; 1）构成的。 n % (n - L) == 0：\n这个条件确保字符串 s 的总长度 n 必须能被这个最小重复单元的长度 (n - L) 整除。 如果能整除，就意味着 s 能够被这个 (n - L) 长度的子串完整、无缝地重复拼接而成。 综合：s.size() % (s.size() - next[s.size() - 1]) == 0 \u0026amp;\u0026amp; next[s.size() - 1] \u0026gt; 0\n4. KMP 算法的核心机制复习 next 数组的计算 (get_next 函数)：\n目标： 计算 next[i]，即 s[0...i] 的最长相等真前缀和真后缀的长度。 核心逻辑： 使用两个指针 i 和 j。i 遍历模式串，j 表示当前已匹配的最长公共前后缀的长度。 失配 (needle[i] != needle[j])： 当 needle[i] 和 needle[j] 不匹配时，j 会根据 next[j-1] 的值进行回溯。这个 while 循环会持续进行，直到 j 归零或找到新的匹配点。 匹配 (needle[i] == needle[j])： 当 needle[i] 和 needle[j] 匹配时，j 会简单地 j++，表示找到了一个更长的公共前后缀。 赋值： 最终计算出的 j 值（代表长度）赋给 next[i]。 j 的双重身份： j 的值既是当前最长公共前后缀的长度，也是模式串中该最长前缀之后一个字符的索引。 KMP 匹配中的 next 数组作用：\n在主串 haystack 和模式串 needle 匹配过程中，当 haystack[i] 和 needle[j] 失配时，j 会回溯到 next[j-1]。 这利用了 needle[0...j-1] 这段已匹配子串的内部结构，让模式串高效地“滑动”，从而避免了主串指针 i 的回溯，也避免了模式串从头开始的重复比较。 5.循环不变量与算法的优雅 get_next 函数中 j 的循环不变量： 在 for 循环的每次迭代开始时，j 的值始终代表 needle[0...i-1] 的最长公共前后缀的长度。while 循环的回溯和 if 语句中的 j++ 操作都是为了维护这个不变式。 strStr 函数中 j 的循环不变量： 在 for 循环的每次迭代开始时，j 的值表示 needle[0...j-1] 已经和 haystack[i-j...i-1] 成功匹配。 意义： 循环不变量是理解和设计复杂循环算法的强大工具，它提供了高层次的视角，证明算法正确性，并指导设计。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: bool repeatedSubstringPattern(string s) { // s长度大于1, 所以不需要自己判断 int n = s.size(); vector\u0026lt;int\u0026gt; next(n); next[0] = 0; int j = 0; // 得到next数组 for (int i = 1; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) { j = next[j - 1]; } if (s[i] == s[j]) { j++; } next[i] = j; } // 如果是由重复子串构成, next[n-1]即模式串的 // 真前缀和真后缀相等的最大长度 不为0, 且s的长度是next[n-1]的整数倍 if (next[n - 1] \u0026gt; 0 \u0026amp;\u0026amp; s.size() % next[n - 1] == 0) { return true; } else { return false; } } }; ","date":"2025-05-22T20:58:14+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day9/","title":"代码随想录_day9"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n1_反转字符串I_leetcode_344 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;vector\u0026gt; using namespace std; class Solution { private: void swapString(vector\u0026lt;char\u0026gt; \u0026amp;s, int left, int right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; } public: void reverseString(vector\u0026lt;char\u0026gt; \u0026amp;s) { int left, right; for (left = 0, right = s.size() - 1; left \u0026lt; right; left++, right--) { swapString(s, left, right); } } }; 2_反转字符串II_leetcode_541 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: void swapString(string \u0026amp;s, int left, int right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; } // 反转left到right的字符串, 是闭区间 void reverseString(string \u0026amp;s, int left, int right) { for (; left \u0026lt; right; left++, right--) { swapString(s, left, right); } } string reverseStr(string s, int k) { for (int i = 0; i \u0026lt; s.size(); i += 2 * k) { // 反转前k个, 条件是i+k不超出s.size() if (i + k \u0026lt; s.size()) { this-\u0026gt;reverseString(s, i, i + k - 1); } // 如果剩下的没有k个, 反转剩下的 else { this-\u0026gt;reverseString(s, i, s.size() - 1); } } return s; } }; 3_替换数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s; while (cin \u0026gt;\u0026gt; s) { int old_len = s.size(); int count = 0; // 1.统计字符中数字出现的次数 for (auto i : s) { if (i \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; i \u0026lt;= \u0026#39;9\u0026#39;) { count++; } } // 2.每个数字都要替换成number, 也就以为着数组增加5*count s.resize(old_len + 5 * count); int new_len = s.size(); // 用双指针遍历 int left, right; for (left = old_len - 1, right = new_len - 1; left \u0026gt; -1; left--) { // left的内容是数字 if (s[left] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[left] \u0026lt;= \u0026#39;9\u0026#39;) { s[right--] = \u0026#39;r\u0026#39;; s[right--] = \u0026#39;e\u0026#39;; s[right--] = \u0026#39;b\u0026#39;; s[right--] = \u0026#39;m\u0026#39;; s[right--] = \u0026#39;u\u0026#39;; s[right--] = \u0026#39;n\u0026#39;; } // left的内容是非数字 else { s[right--] = s[left]; } } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } } ","date":"2025-05-22T12:11:29+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day8/","title":"代码随想录_day8"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n最近复习压力比较大, 没有时间做笔记和额外训练, 目前只做了大概的最优解, 后面二轮的时候要补充完\n5_四数相加II_leetcode_454 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: // // 哈希法 int fourSumCount(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2, vector\u0026lt;int\u0026gt; \u0026amp;nums3, vector\u0026lt;int\u0026gt; \u0026amp;nums4) { // 初始定义map unordered_map\u0026lt;int, int\u0026gt; res_map; // 遍历数组1,2, 对map进行初始化 for (auto a : nums1) { for (auto b : nums2) { auto it = res_map.find(a + b); // unordered_map在创建未存在的键的时候会自动初始赋值为0, // 所以不需要手动初始化 不存在则value赋值为1 // 存在则value++ res_map[a + b]++; } } // 定义符合条件的四元组个数 int count = 0; // 遍历数组3,4,在map中找对应的target的value for (auto c : nums3) { for (auto d : nums4) { int target = 0 - (c + d); auto it = res_map.find(target); // 找到的情况下 if (it != res_map.end()) { count += res_map[target]; // } } } return count; } }; 6_赎金信_leetcode_383 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: bool canConstruct(string ransomNote, string magazine) { // ransomNote 和 magazine 由小写英文字母组成 // 可以用长度26的数组作为哈希表, magazing出现过的字符, 对应值+1, // for循环遍历ransomNote, 看哈希表中有没有对应的字符 vector\u0026lt;int\u0026gt; res_vec(26, 0); for (auto i : magazine) { res_vec[i - \u0026#39;a\u0026#39;]++; } for (auto i : ransomNote) { if (res_vec[i - \u0026#39;a\u0026#39;] \u0026gt; 0) { res_vec[i - \u0026#39;a\u0026#39;]--; } else { return false; } } return true; } }; int main() { string ransomNote = \u0026#34;aa\u0026#34;; string magazine = \u0026#34;aab\u0026#34;; Solution sol; bool flag = sol.canConstruct(ransomNote, magazine); // canConstruct(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) -\u0026gt; false printf(\u0026#34;canConstruct(\\\u0026#34;%s\\\u0026#34;, \\\u0026#34;%s\\\u0026#34;) -\u0026gt; %s\\n\u0026#34;, ransomNote.c_str(), magazine.c_str(), flag ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); return 0; } 7_三数之和_leetcoe_15 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 0. 处理边界情况：如果元素数量不足3个，直接返回空 if (nums.size() \u0026lt; 3) { return {}; } // 最后返回的值是多个三元组, 三元组的内容设为[i,j,k], ijk的和为0, // 且ijk的序号不能相同, 三元组不能重复 // 对数组进行排序 sort(nums.begin(), nums.end()); // 如果最小值大于0, 也就以为三元组不可能存在, 返回空; if (nums[0] \u0026gt; 0) { return {}; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res_vec; // 对数组进行遍历 // 使用i, left, right就是为了避免序号相同 // 对i, left, right去重, 是为了避免三元组重复 for (int i = 0; i \u0026lt; nums.size() - 2; i++) { // 进入循环前需要去i的重, 重复的情况下结束本次循环 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } // 定义left和right指针 int left = i + 1; int right = nums.size() - 1; // right指针永远指向末尾会不会重复? 不会, 因为i去重了 // 因为序号不能相同, 也就是退出循环时, right =left while (right \u0026gt; left) { int temp = nums[i] + nums[left] + nums[right]; if (temp \u0026gt; 0) { right--; } else if (temp \u0026lt; 0) { left++; } // temp = 0; else { res_vec.push_back({nums[i], nums[left], nums[right]}); // 当i,left,right的值刚好为0时, 此时i是固定的, // 如果只动right或则left, 是找不到值的 也就是这种情况下, // 为了找继续可能存在的值, left和right都必须收缩 do { left++; } // 对left和while去重, 必须用循环处理, 退出条件是前后不相等, // 这有可能导致right和left错位 // 综上, 循环条件是前后相等 且 left \u0026lt; right while (nums[left] == nums[left - 1] \u0026amp;\u0026amp; left \u0026lt; right); do { right--; } while (nums[right] == nums[right + 1] \u0026amp;\u0026amp; left \u0026lt; right); } } } return res_vec; } }; 8_四数之和_leetcode_18 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; one_fourSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res_vec; // vector初始化的数组为空 sort(nums.begin(), nums.end()); // 0.处理边界情况 if (nums.size() \u0026lt; 4) { return {}; } // i最多到nums.size()-4 for (int i = 0; i \u0026lt; nums.size() - 3; i++) { // 1.1 i剪枝 // target大于0的情况下, nums[i]如果大于target, 则无解, // 而且意味着后续的i也无解, 所以要结束循环, 而不是结束本次循环 // target \u0026gt;= 0 , nums[i]可否等于target // target =0的情况下, num[i]=target=0,后续的值也可以找到四元组, // 比如{0,0,0,0}, 因为数组单调不减 // 总结 // target=0 , nums[i] \u0026gt; target // target \u0026gt;0的情况, nums[i] \u0026gt;=target if (target == 0 \u0026amp;\u0026amp; nums[i] \u0026gt; target || target \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= target) { break; } // 1.2 i去重 // i重复的情况下, 结束本次循环 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; nums.size() - 2; j++) { // 2.1 j 剪枝 // 在有i的基础上, 如果targe \u0026gt;= 0, nums[i] + nums[j] \u0026gt;= target // \u0026gt;=0 ,也就意味着不可能是目标的四元组 if (target == 0 \u0026amp;\u0026amp; nums[i] + nums[j] \u0026gt; target || target \u0026gt; 0 \u0026amp;\u0026amp; nums[i] + nums[j] \u0026gt;= target) { break; } // 2.2 j去重 // j \u0026gt; 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) // 这个去重逻辑有问题,i和j的值可以相等 // 实际上这里要避免的是i和j同时和上一轮的相同 // 也就是结束循环的条件是j\u0026gt;1, i和上一轮的相同且j和上一轮相同 // i的初始值是0, j的初始值是1, 也就是j要大于1 if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } int left = j + 1; int right = nums.size() - 1; while (left \u0026lt; right) { long long temp = (long long)nums[i] + nums[j] + nums[left] + nums[right]; if (temp \u0026gt; target) right--; else if (temp \u0026lt; target) left++; // temp=target else { // 添加四元组 res_vec.push_back( {nums[i], nums[j], nums[left], nums[right]}); // 去重 do { left++; } while (nums[left] == nums[left - 1] \u0026amp;\u0026amp; left \u0026lt; right); do { right--; } while (nums[right] == nums[right + 1] \u0026amp;\u0026amp; left \u0026lt; right); }; } } } return res_vec; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res_vec; if (nums.size() \u0026lt; 4) return res_vec; sort(nums.begin(), nums.end()); size_t length = nums.size(); for (int i = 0; i \u0026lt; length - 3; i++) { // 1.剪枝 // 最小的组合都大于target ,无解, break if ((long long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] \u0026gt; target) { break; } // 初始值加最大的三个组合都小于target, 说明当前值肯定不行 if ((long long)nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] \u0026lt; target) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; length - 2; j++) { if ((long long)nums[i] + nums[j] + nums[j + 1] + nums[j + 2] \u0026gt; target) { break; } if ((long long)nums[i] + nums[j] + nums[length - 2] + nums[length - 1] \u0026lt; target) { continue; } if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } int left = j + 1; int right = nums.size() - 1; while (left \u0026lt; right) { long long sum = (long long)nums[i] + nums[j] + nums[left] + nums[right]; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { res_vec.push_back( {nums[i], nums[j], nums[left], nums[right]}); do { left++; } while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left - 1]); do { right--; } while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right + 1]); } } } } return res_vec; } }; int main() { vector\u0026lt;int\u0026gt; nums = {-2, -1, -1, 1, 2, 2}; int target = 0; Solution sol; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res_vec = sol.fourSum(nums, target); for (auto i : res_vec) { cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (auto j : i) { cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","date":"2025-05-21T17:37:44+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day7/","title":"代码随想录_day7"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n1_有效的字母异位词_leetcode_242 未完成的任务 对unicode的情况进行处理\n1. 暴力解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 暴力解法 // 遍历s,t两个数组, 对s中每一个字符, 在t中找到对应的字符, // 为了防止重复匹配到已匹配的字符, 需要对匹配的字符进行换值, 因此t需要备份, bool baoli_isAnagram(string s, string t) { // 长度不等直接false if (s.length() != t.length()) { return false; } // 因为要对t修改, 提前备份 string t_backup = t; // 定义1个bool值, 表示当前s的字符是否匹配上t了 bool found; for (int i = 0; i \u0026lt; s.length(); i++) { found = false; for (int j = 0; j \u0026lt; t_backup.length(); j++) { // 如果相等的话 if (s[i] == t_backup[j]) { found = true; t_backup[j] = \u0026#39;#\u0026#39;; // 对匹配到的字符进行更替, 防止重复匹配 break; // s的字符已经找到了对应的字符, 没必要找了 } } // s的一个字符在t中没找到, 直接返回false if (found == false) { return false; } } return true; } 2. 数组哈希解法_最优解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 只处理小写字母, 而不是unicode编码, 小写字母的ascii码有26个, // 所以只需要长度为26的数组, 遍历s,t将每个字符映射到数组的索引, 然后++ // 如果数组中的值均为2, 则s,t是字母异位词, 有问题, // 字符串里面的字符可以重复出现, // 也就是出现偶数个才是正确的, 还是有问题, 如果是 aa 和 bb,也会是偶数 // 所以最好的思路是, t中的字符++, s中的字符--, // 如果字符在数组中对应的值为0的话, 也就意味着字符相等 bool isAnagram(string s, string t) { if (s.length() != t.length()) { return false; } vector\u0026lt;int\u0026gt; hash_vec(26); for (int i = 0; i \u0026lt; s.length(); i++) { hash_vec[s[i] - \u0026#39;a\u0026#39;]++; hash_vec[t[i] - \u0026#39;a\u0026#39;]--; } for (int i = 0; i \u0026lt; hash_vec.size(); i++) { if (hash_vec[i] != 0) { return false; } } return true; } 2_两个数组的交集_leetcode_349 1. 暴力解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 用1个额外的数组存储交点 (这个做法是错误的, 数组无法去重) // 空间复杂度o(min(n,m)), 时间复杂度o(n*m) vector\u0026lt;int\u0026gt; baoli_intersection(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2) { unordered_set\u0026lt;int\u0026gt; intersection_set; for (int i = 0; i \u0026lt; nums1.size(); i++) { for (int j = 0; j \u0026lt; nums2.size(); j++) { if (nums1[i] == nums2[j]) { intersection_set.insert(nums1[i]); break; } } } return vector\u0026lt;int\u0026gt;(intersection_set.begin(), intersection_set.end()); } 2. 哈希集合解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 哈希集合解法 vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2) { // unordered_set无序, 数值不可以重复, 值不能更改, // 所以存储结果必须单开集合 // 找到长, 短数组 vector\u0026lt;int\u0026gt; nums_short = nums1.size() \u0026lt; nums2.size() ? nums1 : nums2; vector\u0026lt;int\u0026gt; nums_long = nums1.size() \u0026lt; nums2.size() ? nums2 : nums1; unordered_set\u0026lt;int\u0026gt; nums_set(nums_short.begin(), nums_short.end()); unordered_set\u0026lt;int\u0026gt; res_set; for (int num : nums_long) { // 在nums_set中找有没有相同的值, 有则加入 // find的结果 // 1. 找到的情况下返回当前值的迭代器 // 2.没找到的情况下返回nums_set.end() if (nums_set.find(num) != nums_set.end()) { res_set.insert(num); } } return vector\u0026lt;int\u0026gt;(res_set.begin(), res_set.end()); // 1.时间复杂度分析 // 循环中需要遍历长数组, 最坏情况下, 时间复杂度为o(max(n,m)) // 2.空间复杂度分析 // 2.1 将最小数组存入集合中, 空间复杂度o(min(n,m)) // 2.2 res_set用于存放相交的值, 空间复杂度为o(k), k\u0026lt;= o(min(n,m)) // 2.3 最后返回的数组, 空间复杂同为o(k) // 综合来看, 空间复杂度为o(min(n,m)) } 3. 数组+哈希集合_最优解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 最优解 // 由于题目规定了数值仅在0-1000, // 最开始放短数组的值可以放在数组中, 数组的开销小, 能用数组就不要用set, // 使用数字必须在空间确定的情况下, 不确定的情况习, 容易造成空间浪费, // 这种情况下用set 所以存放数值还是必须要放在哈希表中, 因为最后要不重复 vector\u0026lt;int\u0026gt; better_intersection(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2) { vector\u0026lt;int\u0026gt; nums_array(1001, 0); unordered_set\u0026lt;int\u0026gt; res_set; // 找到长短数组 vector\u0026lt;int\u0026gt; nums_short = nums1.size() \u0026lt; nums2.size() ? nums1 : nums2; vector\u0026lt;int\u0026gt; nums_long = nums1.size() \u0026lt; nums2.size() ? nums2 : nums1; // 遍历短数组, 用其值作为索引, 出现的情况下+1, 后续判断是否相交, // 即对长数组遍历, 判断其值的索引的值是否为1即可 for (int num : nums_short) { nums_array[num] = 1; } for (int num : nums_long) { if (nums_array[num] == 1) { res_set.insert(num); } } return vector\u0026lt;int\u0026gt;(res_set.begin(), res_set.end()); } 3_快乐数_leetcode_202 1. 哈希集合法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int get_sum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n = n / 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; res_set; int sum; while (true) { sum = get_sum(n); if (sum == 1) { return true; } if (res_set.find(sum) != res_set.end()) { return false; } else { res_set.insert(sum); } n = sum; } } 2. 快慢指针法_最优解 自己最初写的, 写的很繁琐, 没要考虑到fast和slow, 无论是有解还是无解, 最终都要相等, 有解的情况下相等值为1, 无解的情况下相等值非1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 因为无解的情况下, 会陷入循环, 陷入循环的情况下, // 如果快指针和慢指针同时出发, 快指针一定会套圈, 追上慢指针 // 比如 2 -\u0026gt; 4 -\u0026gt; 16 -\u0026gt; 37 -\u0026gt; 58 -\u0026gt; 89 -\u0026gt; 145 -\u0026gt; 42 -\u0026gt; 20 -\u0026gt; 4 // 有解的情况下, 没有循环 比如 // 1 -\u0026gt; 1 -\u0026gt; 1 bool better_isHappy(int n) { int slow, fast; // 初始化 slow = get_sum(n); fast = get_sum(n); fast = get_sum(fast); if (fast == 1) { return true; } // 也就是无解的情况下, 一定会退出循环, 有解的情况下, 快指针一定为1 while (fast != slow) { if (fast == 1) { return true; } slow = get_sum(slow); fast = get_sum(fast); fast = get_sum(fast); } return false; } 参考答案写的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool better_2_isHappy(int n) { int fast, slow; fast = slow = n; // // 初始化 // slow = get_sum(slow); // fast = get_sum(fast); // fast = get_sum(fast); // 快指针和慢指针在哪种情况下都会相遇, 无解的情况下相遇的值不为1, // 有解的情况相遇的值为1 do { slow = get_sum(slow); fast = get_sum(fast); fast = get_sum(fast); } while (fast != slow); return slow == 1; } ; 4_两数之和_leetcode_1 1. 暴力解法 1 2 3 4 5 6 7 8 9 10 11 vector\u0026lt;int\u0026gt; baoli_twoSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 暴力做法 // 遍历嵌套两次 for (int i = 0; i \u0026lt; nums.size(); i++) { for (int j = i + 1; j \u0026lt; nums.size(); j++) { if (nums[i] + nums[j] == target) { return vector\u0026lt;int\u0026gt;{i, j}; } } } } 2. map解法_最优解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 遍历nums数组, 在map中找target-遍历值, // 找到了则输出它们的index // 找不到则在map中存储 遍历值:index unordered_map\u0026lt;int, int\u0026gt; nums_map; for (int i = 0; i \u0026lt; nums.size(); i++) { auto itter = nums_map.find(target - nums[i]); // 找到这个元素的情况下 if (itter != nums_map.end()) { // 返回这对键值对 return vector\u0026lt;int\u0026gt;{nums_map[target - nums[i]], i}; } // 没找到这个元素的情况下 else { nums_map.insert({nums[i], i}); } } // 如果没有找到符合条件的两个数，返回空vector return {}; } ","date":"2025-05-19T19:00:30+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day6/","title":"代码随想录_day6"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n总结 虚拟头结点的序号记为-1, 头结点记为0\ntail节点, 一直指向最后1个节点\ntail节点更新的情况\n1.链表0个节点, 头部插入 2.尾部插入 3.任意序号插入, 尾部插入\n易错 addAtIndex 没有处理 index \u0026gt; _size 的情况 添加到尾部的条件错误, 添加到尾部的正确条件是 index == _size deleteAtIndex 1.没更新_size 2.temp指针的空间删除后, 要指向空 3.没有考虑删除尾结点的时候, 要更新_tail 4.没有考虑到删除节点后, 链表为空, 要更新_tail\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 // 定义链表 struct LinkNode { int val; struct LinkNode *next; // 构造函数体 LinkNode() : val(0), next(nullptr) {} LinkNode(int x) : val(x), next(nullptr) {} LinkNode(int x, LinkNode *node) : val(x), next(node) {} }; class MyLinkedList { private: int _size; LinkNode *_dummyHead; LinkNode *_tail; public: MyLinkedList() { _size = 0; _dummyHead = new LinkNode(); _tail = _dummyHead; } int get(int index) { // 判断是否有效 index if (index \u0026lt; 0 || index \u0026gt; _size - 1) { return -1; } LinkNode *cur = _dummyHead; for (int i = 0; i \u0026lt;= index; i++) { cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } void addAtHead(int val) { LinkNode *new_node = new LinkNode(val); new_node-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = new_node; if (_size == 0) { _tail = new_node; } _size++; } void addAtTail(int val) { LinkNode *new_node = new LinkNode(val); _tail-\u0026gt;next = new_node; _tail = new_node; _size++; } void addAtIndex(int index, int val) { // 原始错误 // 1. inde\u0026gt;_size, 没有处理 // 2. 添加到尾部的判断错误, 添加到尾部的添加是index==_size if (index \u0026gt; _size) { return; // index \u0026lt;=0 头部插入 } if (index \u0026lt;= 0) { addAtHead(val); return; } // index = _size-1, 不是尾部插入 , 理解错了, _size-1是尾结点, // index = _size-1 插入实际上是后面的逻辑 if (index == _size) { addAtTail(val); return; } // 0 \u0026lt; index \u0026lt; _size LinkNode *cur = _dummyHead; LinkNode *new_node = new LinkNode(val); // 在index处停止 for (int i = 0; i \u0026lt; index; i++) { cur = cur-\u0026gt;next; } new_node-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = new_node; _size++; } void deleteAtIndex(int index) { // 原始错误 // 1.没更新_size // 2.temp指针的空间删除后, 要指向空 // 3.没有考虑删除到尾结点的时候, _tail的更新 // 4.没有考虑到删除后, 链表为空的情况 if (index \u0026lt; 0 || index \u0026gt; _size - 1) { return; } LinkNode *cur = _dummyHead; for (int i = 0; i \u0026lt; index; i++) { cur = cur-\u0026gt;next; } LinkNode *temp = cur-\u0026gt;next; // 删除的是尾结点 if (temp == _tail) { _tail = cur; } cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete temp; temp = nullptr; _size--; // 删除后如果长度为0 if (_size == 0) { _tail = _dummyHead; } } ~MyLinkedList() { LinkNode *current = _dummyHead; while (current != nullptr) { LinkNode *next = current-\u0026gt;next; // 先保存下一个节点的地址 delete current; // 删除当前节点 current = next; // 移动到下一个节点 } _dummyHead = nullptr; // 删除完后，将头指针置空 _tail = nullptr; // 尾指针也置空 _size = 0; // 尺寸归零 } }; ","date":"2025-05-18T16:41:36+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/leetcode_707_%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8_%E7%94%A8size%E5%92%8Ctail/","title":"leetcode_707_设计链表_用size和tail"},{"content":"双指针法1(卡哥思路) 思路和总结 把链表想象为一根绳子, 让绳子右端点对齐\n1.分别遍历A,B两个链表, 得出A,B的长度 2.让长链表的初始指针移动到, 和短链表初始指针对齐\n本次题暴露了自己循环体理解的问题, while和for是等价的\n写好循环体, 一般是通过对应关系去写条件\n对应关系: 本次循环体刚进来的判别的对象 和 对应的变化值\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { // 处理长度为0的情况 if (headA == nullptr || headB == nullptr) { return nullptr; } // 1. 计算链表长度 // 链表的索引从0开始 ListNode *curA, *curB; curA = headA; int len_A, len_B; len_A = 0; len_B = 0; // curA是判别对象 while (curA != nullptr) { curA = curA-\u0026gt;next; len_A++; // 索引 0 -\u0026gt; 长度 1, 正确 } curB = headB; while (curB != nullptr) { curB = curB-\u0026gt;next; len_B++; } // 2. 重置指针 curA = headA; curB = headB; // 3. 将长链表的指针向前移动长度差的步数进行对齐 if (len_A \u0026gt; len_B) { // 从0移动到LA-LB,步数为LA-LB for (int i = 1; i \u0026lt;= (len_A - len_B); i++) { curA = curA-\u0026gt;next; } } if (len_A \u0026lt; len_B) { for (int i = 1; i \u0026lt;= (len_B - len_A); i++) { curB = curB-\u0026gt;next; } } // 现在curA和curB在同一起点, 同时出发 while (curA != nullptr \u0026amp;\u0026amp; curB != nullptr) { if (curA == curB) { return curA; } curA = curA-\u0026gt;next; curB = curB-\u0026gt;next; } return nullptr; } }; 双指针法2 思路和总结 设A独有的长度为a, 和B相同的部分为c; 设B独有长度为b, 和A相同的部分为c; 让A,B链表拼接在一起.\n1 A,B有相同的部分\nurA 从 A 端出发, curB 从 B 端出发, curA 第一次到达相同部分, 移动的距离是a-1 curA 第二次到达相同部分, 移动的距离是a+c-1+b curB 第一次到达相同的部分, 移动的距离是b-1 curB 第二次到达相同的部分, 移动的距离是b+c-1+a 即A,B有相同的部分, 它们一定会移动相同的距离 a+b+c-1, 遇到第一个相等的对象.\n2 A, B没有相同的部分\nA,B会走完全程, 遇到1个相等的对象 nullptr\n总结: 通过让两个指针走的总路程相等(LA+LB)，它们一定会在某个时刻相遇。 而这个相遇点，必然是它们第一次同时到达的、在两条“加长”路径上具有相同相对位置的那个点，也就是相交点（如果存在的话），或者最终的 nullptr（如果不相交的话）。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (!headA || !headB) return nullptr; ListNode *curA, *curB; curA = headA; curB = headB; // 循环退出条件, curA, curB相等 while (curA != curB) { curA = curA == nullptr ? headB : curA-\u0026gt;next; curB = curB == nullptr ? headA : curB-\u0026gt;next; } return curA; } }; 暴力解法 总结 原始错误\n循环嵌套需要初始化curB, 此前没有初始化curB\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { // 0个节点 if (headA == nullptr || headB == nullptr) { return nullptr; } // 暴力解法, 同时遍历A和B, 有个相等时即return ListNode *curA = headA; while (curA != nullptr) { ListNode *curB = headB; // 注意要初始化 while (curB != nullptr) { if (curA == curB) { return curA; } curB = curB-\u0026gt;next; } curA = curA-\u0026gt;next; } return nullptr; } }; ","date":"2025-05-18T16:22:06+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/leetcode_%E9%9D%A2%E8%AF%95%E9%A2%98_0207_%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/","title":"Leetcode_面试题_0207_链表相交"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n今日BB 前天在配置wsl环境和博客, 昨天只做了区间和开发商问题, 链表的任务全部拖到今天解决了, 花了大半天写完了, 链表还剩链表相交, 今天没时间做了.\n数组收获 开发商题目中最大收获就是在处理行/列分割的时候, 可以用行, 列前缀和处理.\n我最原始的思路是n行m列矩阵, 如果按行分割, 这里约定被分割的行及其前面的都属于前一部分的, 列分割同理, 那行分割的序号可以从1到n-1, 按照矩阵的索引来说, 就是 0 到 n-2.\n比如3行的矩阵\n行分割索引为0, 则分割为[0], [1,2] 行分割索引为1, 则分割为[0,1],[2] 同理列分割的索引可以从0到n-2.\n想到这里的时候, 我是想把分割后的差值的绝对值求出来, 最后一起求最小值, 但是非常繁琐. 看了卡哥的代码豁然开朗.\n1 2 3 4 5 6 7 8 9 10 11 12 int result = INT_MAX; int horizontalCut = 0; for (int i = 0; i \u0026lt; n; i++) { horizontalCut += horizontal[i]; result = min(result, abs(sum - horizontalCut - horizontalCut)); } int verticalCut = 0; for (int j = 0; j \u0026lt; m; j++) { verticalCut += vertical[j]; result = min(result, abs(sum - verticalCut - verticalCut)); } cout \u0026lt;\u0026lt; resu horizontal 和 vertical是前面算出来的矩阵的每行, 毎列的和. sum是矩阵所有元素的和, 这里最开始看不懂的是horizontalCut干嘛的.\n实际上思路和我们前面是一样的, 要求分割后的差值.\ni=0, horizontalCut为第1行的和, 而sum - horizontalCut即为2,3行的和.\n所以i=0时, sum - horizontalCut - horizontalCut即是分割索引为0时, 上下两部分的差值.\n这里的for循环即是把所有分割的可能的差值求出来, 每次都在更新result.\n美中不足的是, i \u0026lt; n不是最精确的范围:\ni = n-1时, horizontal是全部行的和, 这个分割的差值显然是0, 逻辑完善的话, for循环条件应为 i \u0026lt; n - 1.\n链表收获 今天链表比较欠缺的部分是 设计链表 是用不含size属性实现的, 后续要做含size属性的以及双链表.\n之前以为数据结构学过链表, 这里没啥问题. 结果在设计链表的边界处理, 犯了很多错误:\n在链表尾处添加节点, 没有考虑到空节点的情况 两两交换链表中的节点和环形链表中都用了步长为2的指针, 这里最需要注意的就是快指针的边界处理, 很容易操作空指针.\n","date":"2025-05-17T20:31:55+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day4_%E9%93%BE%E8%A1%A8/","title":"代码随想录_day4_链表"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n今日收获 基础题1-6都做完了, 比想象中的简单. 今天学习到最多的就是力扣编号34的, 在排序数组中查找元素的第一个和最后一个位置.\n我原本以为这个和二分查找一样简单, 但发现这个是用二分查找边界. 和卡哥在二分查找的循环变量不同, 思考了2个小时才搞懂, 特此记录下笔记.\n二分查找边界思路 左边界即数组中第1个大于等于target的值, 右边界即数组中第1个大于target的值.\n以二分查找右边界为例, 我们这里采用的循环不变量是[0, left), [right,n).\n这里的n即为数组长度, 采用左闭右开的方式.\n按照循环不变量的思路, 初始化left=0, right=nums.size(). 循环结束条件是left \u0026lt; right.\n精彩的地方来了, 我们如何查找到右边界呢?\n我们只要保证\n[0, left)的数组值严格小于等于target\n[right,n)的值严格大于target 然后不断扩大它们的范围, 直至left=right. 它们相等的值左边小于target, 而这个值本身又大于等于target, 故得出它是第一个大于target的值, 即查找到右边界了, 以上都是建立在target在数组中的.\n如果不在数组中呢?\n1.target在数组的左侧外 2.target在数组的右侧外 3.targe在数组中, 但数组中没有target的这个值\n带入思考, 发现依然能够得出正确的值, 1的右边界索引为0, 2的右边索引为n, 3的右边界索引即为第1个大于target的值的索引.\n左边界的思路同理, 只要保证\n[0, left)的数组值严格小于target\n[right,n)的值严格大于等于target\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left_border = LeftBorder(nums, target); if (left_border == int(nums.size()) || nums[left_border] != target) { return {-1, -1}; } int right_border = RightBoreder(nums, target) - 1; return {left_border, right_border}; } private: int RightBoreder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 缩小区间找第一个大于target的值 int left, right, mid; right = int(nums.size()); left = 0; while (left \u0026lt; right) // [right,n-1)的值严格大于targt // [0, left)的值严格小于等于target // 最后left==right { mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid; } // nums[mid] \u0026lt;= target // 因为left处于开的位置, 已知mid\u0026lt;=target, 故left = mid+1 else { left = mid + 1; // } } return left; } int LeftBorder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left, right, mid; left = 0; right = int(nums.size()); while (left \u0026lt; right) { mid = left + (right - left) / 2; if (nums[mid] \u0026gt;= target) { right = mid; } // nums[mid] \u0026lt; target else { left = mid + 1; } } return left; } }; int main() { vector\u0026lt;int\u0026gt; nums = {5,7,7,8,8,10}; int target = 8; Solution s; vector\u0026lt;int\u0026gt;result = s.searchRange(nums,target); cout \u0026lt;\u0026lt;\u0026#34;Result for \u0026#34;\u0026lt;\u0026lt; target \u0026lt;\u0026lt; \u0026#34;: [\u0026#34; \u0026lt;\u0026lt; result[0] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; result[1] \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-16T15:39:59+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day_1_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%BE%B9%E7%95%8C/","title":"代码随想录_day_1_二分查找边界"},{"content":"简介 这是 粗体 文本，这是 斜体 文本。\n访问 Hugo 网站！\n测试\n","date":"2025-05-16T10:40:00+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/my-first-post/","title":"My First Post"}]