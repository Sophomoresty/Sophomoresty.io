[{"content":"今日BB 前天在配置wsl环境和博客, 昨天只做了区间和开发商问题, 链表的任务全部拖到今天解决了, 花了大半天写完了, 链表还剩链表相交, 今天没时间做了.\n数组收获 开发商题目中最大收获就是在处理行/列分割的时候, 可以用行, 列前缀和处理.\n我最原始的思路是n行m列矩阵, 如果按行分割, 这里约定被分割的行及其前面的都属于前一部分的, 列分割同理, 那行分割的序号可以从1到n-1, 按照矩阵的索引来说, 就是 0 到 n-2.\n比如3行的矩阵\n行分割索引为0, 则分割为[0], [1,2] 行分割索引为1, 则分割为[0,1],[2] 同理列分割的索引可以从0到n-2.\n想到这里的时候, 我是想把分割后的差值的绝对值求出来, 最后一起求最小值, 但是非常繁琐. 看了卡哥的代码豁然开朗.\n1 2 3 4 5 6 7 8 9 10 11 12 int result = INT_MAX; int horizontalCut = 0; for (int i = 0; i \u0026lt; n; i++) { horizontalCut += horizontal[i]; result = min(result, abs(sum - horizontalCut - horizontalCut)); } int verticalCut = 0; for (int j = 0; j \u0026lt; m; j++) { verticalCut += vertical[j]; result = min(result, abs(sum - verticalCut - verticalCut)); } cout \u0026lt;\u0026lt; resu horizontal 和 vertical是前面算出来的矩阵的每行, 毎列的和. sum是矩阵所有元素的和, 这里最开始看不懂的是horizontalCut干嘛的.\n实际上思路和我们前面是一样的, 要求分割后的差值.\ni=0, horizontalCut为第1行的和, 而sum - horizontalCut即为2,3行的和.\n所以i=0时, sum - horizontalCut - horizontalCut即是分割索引为0时, 上下两部分的差值.\n这里的for循环即是把所有分割的可能的差值求出来, 每次都在更新result.\n美中不足的是, i \u0026lt; n不是最精确的范围:\ni = n-1时, horizontal是全部行的和, 这个分割的差值显然是0, 逻辑完善的话, for循环条件应为 i \u0026lt; n - 1.\n链表收获 今天链表比较欠缺的部分是 设计链表 是用不含size属性实现的, 后续要做含size属性的以及双链表.\n之前以为数据结构学过链表, 这里没啥问题. 结果在设计链表的边界处理, 犯了很多错误:\n在链表尾处添加节点, 没有考虑到空节点的情况 两两交换链表中的节点和环形链表中都用了步长为2的指针, 这里最需要注意的就是快指针的边界处理, 很容易操作空指针.\n","date":"2025-05-17T20:31:55+08:00","image":"http://localhost:1313/Sophomoresty.io/img/lucy_1.png","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day_4_%E9%93%BE%E8%A1%A8/","title":"代码随想录_day_4_链表"},{"content":"今日收获 基础题1-6都做完了, 比想象中的简单. 今天学习到最多的就是力扣编号34的, 在排序数组中查找元素的第一个和最后一个位置.\n我原本以为这个和二分查找一样简单, 但发现这个是用二分查找边界. 和卡哥在二分查找的循环变量不同, 思考了2个小时才搞懂, 特此记录下笔记.\n二分查找边界思路 左边界即数组中第1个大于等于target的值, 右边界即数组中第1个大于target的值.\n以二分查找右边界为例, 我们这里采用的循环不变量是[0, left), [right,n).\n这里的n即为数组长度, 采用左闭右开的方式.\n按照循环不变量的思路, 初始化left=0, right=nums.size(). 循环结束条件是left \u0026lt; right.\n精彩的地方来了, 我们如何查找到右边界呢?\n我们只要保证\n[0, left)的数组值严格小于等于target\n[right,n)的值严格大于target 然后不断扩大它们的范围, 直至left=right. 它们相等的值左边小于target, 而这个值本身又大于等于target, 故得出它是第一个大于target的值, 即查找到右边界了, 以上都是建立在target在数组中的.\n如果不在数组中呢?\n1.target在数组的左侧外 2.target在数组的右侧外 3.targe在数组中, 但数组中没有target的这个值\n带入思考, 发现依然能够得出正确的值, 1的右边界索引为0, 2的右边索引为n, 3的右边界索引即为第1个大于target的值的索引.\n左边界的思路同理, 只要保证\n[0, left)的数组值严格小于target\n[right,n)的值严格大于等于target\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left_border = LeftBorder(nums, target); if (left_border == int(nums.size()) || nums[left_border] != target) { return {-1, -1}; } int right_border = RightBoreder(nums, target) - 1; return {left_border, right_border}; } private: int RightBoreder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 缩小区间找第一个大于target的值 int left, right, mid; right = int(nums.size()); left = 0; while (left \u0026lt; right) // [right,n-1)的值严格大于targt // [0, left)的值严格小于等于target // 最后left==right { mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid; } // nums[mid] \u0026lt;= target // 因为left处于开的位置, 已知mid\u0026lt;=target, 故left = mid+1 else { left = mid + 1; // } } return left; } int LeftBorder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left, right, mid; left = 0; right = int(nums.size()); while (left \u0026lt; right) { mid = left + (right - left) / 2; if (nums[mid] \u0026gt;= target) { right = mid; } // nums[mid] \u0026lt; target else { left = mid + 1; } } return left; } }; int main() { vector\u0026lt;int\u0026gt; nums = {5,7,7,8,8,10}; int target = 8; Solution s; vector\u0026lt;int\u0026gt;result = s.searchRange(nums,target); cout \u0026lt;\u0026lt;\u0026#34;Result for \u0026#34;\u0026lt;\u0026lt; target \u0026lt;\u0026lt; \u0026#34;: [\u0026#34; \u0026lt;\u0026lt; result[0] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; result[1] \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-16T15:39:59+08:00","image":"http://localhost:1313/Sophomoresty.io/img/lucy_1.png","permalink":"http://localhost:1313/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day_1_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%BE%B9%E7%95%8C/","title":"代码随想录_day_1_二分查找边界"},{"content":"简介 这是 粗体 文本，这是 斜体 文本。\n访问 Hugo 网站！\n测试\n","date":"2025-05-16T10:40:00+08:00","image":"http://localhost:1313/Sophomoresty.io/img/code.jpg","permalink":"http://localhost:1313/Sophomoresty.io/p/my-first-post/","title":"My First Post"}]