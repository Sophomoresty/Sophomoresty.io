<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n19_单调栈做法_最大二叉树_leetcode_654 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include &lt;stack&gt; #include &lt;vector&gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: TreeNode *constructMaximumBinaryTree(std::vector&lt;int&gt; &amp;nums) { /*单调递减栈能做最大二叉树的原因: 单调栈擅长解决“寻找左右第一个更大/更小元素”问题高度 而对于本题数组中的任意元素 X (nums[i])： X 的左孩子：是 X 左边子数组中作为根的那个元素. 准确说, 是 X 左侧、且在 X 左边第一个比 X 大的元素的右侧范围内的最大值. X 的右孩子：是 X 右边子数组中作为根的那个元素. 准确说, 是 X 右侧、且在 X 右边第一个比 X 大的元素的左侧范围内的最大值. X 的父节点：是 X 左边第一个比它大的元素 和 X 右边第一个比它大的元素 中值较小的那一个. 如果它两边都没有比它大的, 那它就是整个树的根. 恰好符合单调栈的解决问题的特征 */ std::stack&lt;TreeNode *&gt; st; // 存储 TreeNode* 的单调递减栈 // 遍历输入数组中的每个数字 for (int i = 0; i &lt; nums.size(); i++) { // 1. 为当前数字创建一个 TreeNode 节点 TreeNode *cur = new TreeNode(nums[i]); // 2. “收编”阶段 (构建树的左子树) ：处理栈内比 cur 小的元素 // 最后一次循环中的栈顶节点 p 满足: // 是 cur 右侧, 且在 cur 左边第一个比 cur 大的元素的右侧范围内的最大值. // 总结: 循环中最后一次的栈顶节点 p 是 cur 的 左孩子 while (!st.empty() &amp;&amp; st.top()-&gt;val &lt; cur-&gt;val) { TreeNode *p = st.top(); // 获取栈顶节点 p st.pop(); // 将 p 弹出栈 cur-&gt;left = p; } // 3. “被收编”阶段 (构建树的右子树) ： 如果栈非空, 意味着栈内有元素, 且大于cur // 此时的栈顶节点 t 即是 cur左边第一个比它大的元素, cur也是t临近的右侧子数组中的根节点 // 总结: 栈顶是cur的爸爸, cur是栈顶的右孩子 if (!st.empty()) { TreeNode *t = st.top(); // 获取栈顶节点 t t-&gt;right = cur; // 将 cur 设置为 t 的右孩子 } // 4. 入栈 st.push(cur); } // 5. 获取根节点 // 树构建完毕, 栈非空, 栈底即是我们的根节点 // 为什么非空? 为什么栈底是我们的根节点? // 我们维护的栈是单调递减栈, 维护体现在while循环中的pop中. // 根节点一旦入栈后, 将不会再遇到比它更大的元素（因为它已经是最大), // 因此它将永远不会被弹出, 并最终留在栈中, 沉到栈底. // 所以栈一定非空 且 栈底元素即为树的根节点. TreeNode *root = nullptr; // 初始化 root 为 nullptr if (!st.empty()) { root = st.top(); // 初始时 root 指向栈顶（可能是根, 也可能是根的右子孙） while (st.size() &gt; 1) { // 循环弹出, 直到栈中只剩一个元素（根节点） st.pop(); root = st.top(); // 更新 root 为新的栈顶（向栈底移动） } } return root; // 返回最终的根节点 } }; 19_递归做法_最大二叉树_leetcode_654 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { private: // 采取左闭右开 TreeNode *constructMaximumBinaryTree_help(const vector&lt;int&gt; &amp;nums, int start, int end) { // 1.终止条件, 数组为空 if (start &gt;= end) { return nullptr; } // 2.寻找最大值及其索引, 这里时间复杂度有点高, 特别是递归多次的话, 能否优化 int max = nums[start]; int max_index = start; for (int i = start; i &lt; end; i++) { if (nums[i] &gt; max) { max = nums[i]; max_index = i; } } // 3.创建节点 TreeNode *node = new TreeNode(max); // 4.分割数组 // 1) 左子树 int start_left = start; int end_left = max_index; // 2) 右子树 int start_right = max_index + 1; int end_right = end; // 5.递归处理 node-&gt;left = constructMaximumBinaryTree_help(nums, start_left, end_left); node-&gt;right = constructMaximumBinaryTree_help(nums, start_right, end_right); return node; } public: TreeNode *constructMaximumBinaryTree(vector&lt;int&gt; &amp;nums) { return constructMaximumBinaryTree_help(nums, 0, nums.size()); } }; 21_合并二叉树_leetcode_617 问题描述：给定两棵二叉树 root1 和 root2，将它们合并成一棵新二叉树。合并规则是：如果两个节点重叠，则将它们的值相加作为新节点的值；否则，不为空的节点将作为新树的节点。\n">
<title>代码随想录_day17</title>

<link rel='canonical' href='https://Sophomoresty.github.io/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day17/'>

<link rel="stylesheet" href="/Sophomoresty.io/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css"><meta property='og:title' content="代码随想录_day17">
<meta property='og:description' content="代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n19_单调栈做法_最大二叉树_leetcode_654 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include &lt;stack&gt; #include &lt;vector&gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: TreeNode *constructMaximumBinaryTree(std::vector&lt;int&gt; &amp;nums) { /*单调递减栈能做最大二叉树的原因: 单调栈擅长解决“寻找左右第一个更大/更小元素”问题高度 而对于本题数组中的任意元素 X (nums[i])： X 的左孩子：是 X 左边子数组中作为根的那个元素. 准确说, 是 X 左侧、且在 X 左边第一个比 X 大的元素的右侧范围内的最大值. X 的右孩子：是 X 右边子数组中作为根的那个元素. 准确说, 是 X 右侧、且在 X 右边第一个比 X 大的元素的左侧范围内的最大值. X 的父节点：是 X 左边第一个比它大的元素 和 X 右边第一个比它大的元素 中值较小的那一个. 如果它两边都没有比它大的, 那它就是整个树的根. 恰好符合单调栈的解决问题的特征 */ std::stack&lt;TreeNode *&gt; st; // 存储 TreeNode* 的单调递减栈 // 遍历输入数组中的每个数字 for (int i = 0; i &lt; nums.size(); i++) { // 1. 为当前数字创建一个 TreeNode 节点 TreeNode *cur = new TreeNode(nums[i]); // 2. “收编”阶段 (构建树的左子树) ：处理栈内比 cur 小的元素 // 最后一次循环中的栈顶节点 p 满足: // 是 cur 右侧, 且在 cur 左边第一个比 cur 大的元素的右侧范围内的最大值. // 总结: 循环中最后一次的栈顶节点 p 是 cur 的 左孩子 while (!st.empty() &amp;&amp; st.top()-&gt;val &lt; cur-&gt;val) { TreeNode *p = st.top(); // 获取栈顶节点 p st.pop(); // 将 p 弹出栈 cur-&gt;left = p; } // 3. “被收编”阶段 (构建树的右子树) ： 如果栈非空, 意味着栈内有元素, 且大于cur // 此时的栈顶节点 t 即是 cur左边第一个比它大的元素, cur也是t临近的右侧子数组中的根节点 // 总结: 栈顶是cur的爸爸, cur是栈顶的右孩子 if (!st.empty()) { TreeNode *t = st.top(); // 获取栈顶节点 t t-&gt;right = cur; // 将 cur 设置为 t 的右孩子 } // 4. 入栈 st.push(cur); } // 5. 获取根节点 // 树构建完毕, 栈非空, 栈底即是我们的根节点 // 为什么非空? 为什么栈底是我们的根节点? // 我们维护的栈是单调递减栈, 维护体现在while循环中的pop中. // 根节点一旦入栈后, 将不会再遇到比它更大的元素（因为它已经是最大), // 因此它将永远不会被弹出, 并最终留在栈中, 沉到栈底. // 所以栈一定非空 且 栈底元素即为树的根节点. TreeNode *root = nullptr; // 初始化 root 为 nullptr if (!st.empty()) { root = st.top(); // 初始时 root 指向栈顶（可能是根, 也可能是根的右子孙） while (st.size() &gt; 1) { // 循环弹出, 直到栈中只剩一个元素（根节点） st.pop(); root = st.top(); // 更新 root 为新的栈顶（向栈底移动） } } return root; // 返回最终的根节点 } }; 19_递归做法_最大二叉树_leetcode_654 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { private: // 采取左闭右开 TreeNode *constructMaximumBinaryTree_help(const vector&lt;int&gt; &amp;nums, int start, int end) { // 1.终止条件, 数组为空 if (start &gt;= end) { return nullptr; } // 2.寻找最大值及其索引, 这里时间复杂度有点高, 特别是递归多次的话, 能否优化 int max = nums[start]; int max_index = start; for (int i = start; i &lt; end; i++) { if (nums[i] &gt; max) { max = nums[i]; max_index = i; } } // 3.创建节点 TreeNode *node = new TreeNode(max); // 4.分割数组 // 1) 左子树 int start_left = start; int end_left = max_index; // 2) 右子树 int start_right = max_index + 1; int end_right = end; // 5.递归处理 node-&gt;left = constructMaximumBinaryTree_help(nums, start_left, end_left); node-&gt;right = constructMaximumBinaryTree_help(nums, start_right, end_right); return node; } public: TreeNode *constructMaximumBinaryTree(vector&lt;int&gt; &amp;nums) { return constructMaximumBinaryTree_help(nums, 0, nums.size()); } }; 21_合并二叉树_leetcode_617 问题描述：给定两棵二叉树 root1 和 root2，将它们合并成一棵新二叉树。合并规则是：如果两个节点重叠，则将它们的值相加作为新节点的值；否则，不为空的节点将作为新树的节点。\n">
<meta property='og:url' content='https://Sophomoresty.github.io/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day17/'>
<meta property='og:site_name' content='靝Sol'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-06-05T14:31:14&#43;08:00'/><meta property='article:modified_time' content='2025-06-05T14:31:14&#43;08:00'/><meta property='og:image' content='https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg' />
<meta name="twitter:title" content="代码随想录_day17">
<meta name="twitter:description" content="代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n19_单调栈做法_最大二叉树_leetcode_654 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include &lt;stack&gt; #include &lt;vector&gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { public: TreeNode *constructMaximumBinaryTree(std::vector&lt;int&gt; &amp;nums) { /*单调递减栈能做最大二叉树的原因: 单调栈擅长解决“寻找左右第一个更大/更小元素”问题高度 而对于本题数组中的任意元素 X (nums[i])： X 的左孩子：是 X 左边子数组中作为根的那个元素. 准确说, 是 X 左侧、且在 X 左边第一个比 X 大的元素的右侧范围内的最大值. X 的右孩子：是 X 右边子数组中作为根的那个元素. 准确说, 是 X 右侧、且在 X 右边第一个比 X 大的元素的左侧范围内的最大值. X 的父节点：是 X 左边第一个比它大的元素 和 X 右边第一个比它大的元素 中值较小的那一个. 如果它两边都没有比它大的, 那它就是整个树的根. 恰好符合单调栈的解决问题的特征 */ std::stack&lt;TreeNode *&gt; st; // 存储 TreeNode* 的单调递减栈 // 遍历输入数组中的每个数字 for (int i = 0; i &lt; nums.size(); i++) { // 1. 为当前数字创建一个 TreeNode 节点 TreeNode *cur = new TreeNode(nums[i]); // 2. “收编”阶段 (构建树的左子树) ：处理栈内比 cur 小的元素 // 最后一次循环中的栈顶节点 p 满足: // 是 cur 右侧, 且在 cur 左边第一个比 cur 大的元素的右侧范围内的最大值. // 总结: 循环中最后一次的栈顶节点 p 是 cur 的 左孩子 while (!st.empty() &amp;&amp; st.top()-&gt;val &lt; cur-&gt;val) { TreeNode *p = st.top(); // 获取栈顶节点 p st.pop(); // 将 p 弹出栈 cur-&gt;left = p; } // 3. “被收编”阶段 (构建树的右子树) ： 如果栈非空, 意味着栈内有元素, 且大于cur // 此时的栈顶节点 t 即是 cur左边第一个比它大的元素, cur也是t临近的右侧子数组中的根节点 // 总结: 栈顶是cur的爸爸, cur是栈顶的右孩子 if (!st.empty()) { TreeNode *t = st.top(); // 获取栈顶节点 t t-&gt;right = cur; // 将 cur 设置为 t 的右孩子 } // 4. 入栈 st.push(cur); } // 5. 获取根节点 // 树构建完毕, 栈非空, 栈底即是我们的根节点 // 为什么非空? 为什么栈底是我们的根节点? // 我们维护的栈是单调递减栈, 维护体现在while循环中的pop中. // 根节点一旦入栈后, 将不会再遇到比它更大的元素（因为它已经是最大), // 因此它将永远不会被弹出, 并最终留在栈中, 沉到栈底. // 所以栈一定非空 且 栈底元素即为树的根节点. TreeNode *root = nullptr; // 初始化 root 为 nullptr if (!st.empty()) { root = st.top(); // 初始时 root 指向栈顶（可能是根, 也可能是根的右子孙） while (st.size() &gt; 1) { // 循环弹出, 直到栈中只剩一个元素（根节点） st.pop(); root = st.top(); // 更新 root 为新的栈顶（向栈底移动） } } return root; // 返回最终的根节点 } }; 19_递归做法_最大二叉树_leetcode_654 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std; struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; class Solution { private: // 采取左闭右开 TreeNode *constructMaximumBinaryTree_help(const vector&lt;int&gt; &amp;nums, int start, int end) { // 1.终止条件, 数组为空 if (start &gt;= end) { return nullptr; } // 2.寻找最大值及其索引, 这里时间复杂度有点高, 特别是递归多次的话, 能否优化 int max = nums[start]; int max_index = start; for (int i = start; i &lt; end; i++) { if (nums[i] &gt; max) { max = nums[i]; max_index = i; } } // 3.创建节点 TreeNode *node = new TreeNode(max); // 4.分割数组 // 1) 左子树 int start_left = start; int end_left = max_index; // 2) 右子树 int start_right = max_index + 1; int end_right = end; // 5.递归处理 node-&gt;left = constructMaximumBinaryTree_help(nums, start_left, end_left); node-&gt;right = constructMaximumBinaryTree_help(nums, start_right, end_right); return node; } public: TreeNode *constructMaximumBinaryTree(vector&lt;int&gt; &amp;nums) { return constructMaximumBinaryTree_help(nums, 0, nums.size()); } }; 21_合并二叉树_leetcode_617 问题描述：给定两棵二叉树 root1 和 root2，将它们合并成一棵新二叉树。合并规则是：如果两个节点重叠，则将它们的值相加作为新节点的值；否则，不为空的节点将作为新树的节点。\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg' />
    <link rel="shortcut icon" href="/lucy.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/Sophomoresty.io/">
                
                    
                    
                    
                        
                        <img src="/Sophomoresty.io/img/lucy_hu_80d75fc8bcdaf374.png" width="300"
                            height="273" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍥</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/Sophomoresty.io">靝Sol</a></h1>
            <h2 class="site-description">Be What You Wanna Be</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://www.bilibili.com/'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1747382077492" class="icon" viewBox="0 0 1129 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1470" xmlns:xlink="http://www.w3.org/1999/xlink" width="220.5078125" height="200"><path d="M234.909 9.656a80.468 80.468 0 0 1 68.398 0 167.374 167.374 0 0 1 41.843 30.578l160.937 140.82h115.07l160.936-140.82a168.983 168.983 0 0 1 41.843-30.578A80.468 80.468 0 0 1 930.96 76.445a80.468 80.468 0 0 1-17.703 53.914 449.818 449.818 0 0 1-35.406 32.187 232.553 232.553 0 0 1-22.531 18.508h100.585a170.593 170.593 0 0 1 118.289 53.109 171.397 171.397 0 0 1 53.914 118.288v462.693a325.897 325.897 0 0 1-4.024 70.007 178.64 178.64 0 0 1-80.468 112.656 173.007 173.007 0 0 1-92.539 25.75h-738.7a341.186 341.186 0 0 1-72.421-4.024A177.835 177.835 0 0 1 28.91 939.065a172.202 172.202 0 0 1-27.36-92.539V388.662a360.498 360.498 0 0 1 0-66.789A177.03 177.03 0 0 1 162.487 178.64h105.414c-16.899-12.07-31.383-26.555-46.672-39.43a80.468 80.468 0 0 1-25.75-65.984 80.468 80.468 0 0 1 39.43-63.57M216.4 321.873a80.468 80.468 0 0 0-63.57 57.937 108.632 108.632 0 0 0 0 30.578v380.615a80.468 80.468 0 0 0 55.523 80.469 106.218 106.218 0 0 0 34.601 5.632h654.208a80.468 80.468 0 0 0 76.444-47.476 112.656 112.656 0 0 0 8.047-53.109v-354.06a135.187 135.187 0 0 0 0-38.625 80.468 80.468 0 0 0-52.304-54.719 129.554 129.554 0 0 0-49.89-7.242H254.22a268.764 268.764 0 0 0-37.82 0z m0 0" fill="#20B0E3" p-id="1471"></path><path d="M348.369 447.404a80.468 80.468 0 0 1 55.523 18.507 80.468 80.468 0 0 1 28.164 59.547v80.468a80.468 80.468 0 0 1-16.094 51.5 80.468 80.468 0 0 1-131.968-9.656 104.609 104.609 0 0 1-10.46-54.719v-80.468a80.468 80.468 0 0 1 70.007-67.593z m416.02 0a80.468 80.468 0 0 1 86.102 75.64v80.468a94.148 94.148 0 0 1-12.07 53.11 80.468 80.468 0 0 1-132.773 0 95.757 95.757 0 0 1-12.875-57.133V519.02a80.468 80.468 0 0 1 70.007-70.812z m0 0" fill="#20B0E3" p-id="1472"></path></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/Sophomoresty'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1747382114895" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2439" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M0 556.416C0 602.816 4.352 644.8 13.024 682.336 21.696 719.904 33.728 752.544 49.088 780.224 64.416 807.936 83.968 832.32 107.648 853.344 131.36 874.368 157.056 891.552 184.768 904.928 212.48 918.272 244.096 929.12 279.648 937.472 315.2 945.824 351.52 951.648 388.576 955.008 425.632 958.336 466.336 960 510.752 960 555.488 960 596.384 958.336 633.44 955.008 670.496 951.648 706.88 945.824 742.592 937.472 778.304 929.12 810.112 918.272 837.984 904.928 865.856 891.552 891.712 874.368 915.584 853.344 939.456 832.32 959.168 807.936 974.688 780.224 990.208 752.544 1002.304 719.904 1010.976 682.336 1019.648 644.8 1024 602.816 1024 556.416 1024 473.632 996.288 402.016 940.896 341.6 943.872 333.568 946.624 324.48 949.152 314.304 951.648 304.128 953.984 289.6 956.16 270.752 958.336 251.872 957.504 230.112 953.664 205.408 949.824 180.704 942.72 155.488 932.352 129.792L924.864 128.288C919.52 127.296 910.752 127.52 898.56 129.024 886.368 130.528 872.192 133.536 856 138.048 839.808 142.56 818.944 151.232 793.408 164.096 767.872 176.928 740.928 193.056 712.544 212.416 663.808 199.04 596.864 192.384 511.744 192.384 426.944 192.384 360.192 199.04 311.456 212.416 283.072 193.056 255.968 176.928 230.08 164.096 204.224 151.232 183.616 142.56 168.256 138.048 152.896 133.536 138.528 130.624 125.184 129.28 111.84 127.936 103.392 127.52 99.904 128.032 96.384 128.544 93.632 129.12 91.648 129.792 81.28 155.488 74.176 180.672 70.368 205.408 66.528 230.112 65.696 251.872 67.84 270.752 70.016 289.6 72.352 304.128 74.848 314.304 77.376 324.48 80.128 333.568 83.136 341.6 27.712 402.016 0 473.632 0 556.416ZM125.696 682.08C125.696 634.016 147.552 589.952 191.296 549.888 204.288 537.888 219.488 528.8 236.832 522.592 254.208 516.448 273.824 512.928 295.68 512.096 317.536 511.264 338.496 511.424 358.528 512.608 378.56 513.76 403.264 515.36 432.64 517.344 462.016 519.36 487.392 520.352 508.736 520.352 530.112 520.352 555.488 519.36 584.864 517.344 614.24 515.36 638.944 513.76 658.976 512.608 679.008 511.424 699.936 511.264 721.792 512.096 743.68 512.928 763.296 516.448 780.64 522.592 798.016 528.768 813.184 537.888 826.208 549.888 869.952 589.28 891.808 633.344 891.808 682.08 891.808 710.816 888.224 736.256 881.024 758.464 873.856 780.672 864.672 799.264 853.504 814.304 842.304 829.312 826.784 842.08 806.944 852.608 787.072 863.104 767.712 871.2 748.832 876.896 729.984 882.56 705.792 886.976 676.224 890.144 646.688 893.312 620.32 895.232 597.12 895.904 573.92 896.576 544.448 896.928 508.736 896.928 473.024 896.928 443.552 896.576 420.352 895.904 397.152 895.232 370.784 893.312 341.248 890.144 311.712 886.976 287.52 882.56 268.64 876.896 249.792 871.2 230.432 863.104 210.56 852.608 190.688 842.08 175.168 829.312 164 814.304 152.8 799.264 143.616 780.672 136.448 758.464 129.28 736.256 125.696 710.816 125.696 682.08ZM640 672A2 3 2520 1 0 768 672 2 3 2520 1 0 640 672zM256 672A2 3 2520 1 0 384 672 2 3 2520 1 0 256 672z" fill="#000000" p-id="2440"></path></svg>
                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/Sophomoresty.io/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/Sophomoresty.io/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/Sophomoresty.io/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>档案</span>
            </a>
        </li>
        
        
        <li >
            <a href='/Sophomoresty.io/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜素</span>
            </a>
        </li>
        
        
        <li >
            <a href='/Sophomoresty.io/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#19_单调栈做法_最大二叉树_leetcode_654">19_单调栈做法_最大二叉树_leetcode_654</a></li>
    <li><a href="#19_递归做法_最大二叉树_leetcode_654">19_递归做法_最大二叉树_leetcode_654</a></li>
    <li><a href="#21_合并二叉树_leetcode_617">21_合并二叉树_leetcode_617</a>
      <ol>
        <li><a href="#我们遇到的问题与解决方案">我们遇到的问题与解决方案</a></li>
        <li><a href="#最终代码逻辑递归">最终代码逻辑（递归）</a></li>
      </ol>
    </li>
    <li><a href="#22_二叉搜索树中的搜索_leetcode_700">22_二叉搜索树中的搜索_leetcode_700</a>
      <ol>
        <li><a href="#我们遇到的问题与解决方案-1">我们遇到的问题与解决方案</a></li>
      </ol>
    </li>
    <li><a href="#23_验证二叉搜索树_leetcode_98">23_验证二叉搜索树_leetcode_98</a>
      <ol>
        <li><a href="#1-问题描述与核心定义">1. 问题描述与核心定义</a></li>
        <li><a href="#2-核心思路中序遍历的单调性">2. 核心思路：中序遍历的单调性</a></li>
        <li><a href="#3-解法选择与实现方式">3. 解法选择与实现方式</a>
          <ol>
            <li><a href="#递归中序遍历--辅助变量-最优解">递归中序遍历 + 辅助变量 (最优解)</a></li>
            <li><a href="#最终代码逻辑-递归中序遍历符合标准-bst-定义">最终代码逻辑 (递归中序遍历，符合标准 BST 定义)</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day17/">
                
                    <img src="/Sophomoresty.io/img/code.jpg" loading="lazy" alt="Featured image of post 代码随想录_day17" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/Sophomoresty.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" >
                代码随想录
            </a>
        
            <a href="/Sophomoresty.io/categories/c&#43;&#43;/" >
                C&#43;&#43;
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day17/">代码随想录_day17</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 05, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 9 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>代码仓库: <a class="link" href="https://github.com/Sophomoresty/Algorithm_Exercises.git"  target="_blank" rel="noopener"
    >https://github.com/Sophomoresty/Algorithm_Exercises.git</a></p>
<h2 id="19_单调栈做法_最大二叉树_leetcode_654">19_单调栈做法_最大二叉树_leetcode_654
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">constructMaximumBinaryTree</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/*单调递减栈能做最大二叉树的原因:
</span></span></span><span class="line"><span class="cl"><span class="cm">        单调栈擅长解决“寻找左右第一个更大/更小元素”问题高度
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">        而对于本题数组中的任意元素 X (nums[i])：
</span></span></span><span class="line"><span class="cl"><span class="cm">        X 的左孩子：是 X 左边子数组中作为根的那个元素. 准确说, 是 X 左侧、且在 X 左边第一个比 X 大的元素的右侧范围内的最大值. 
</span></span></span><span class="line"><span class="cl"><span class="cm">        X 的右孩子：是 X 右边子数组中作为根的那个元素. 准确说, 是 X 右侧、且在 X 右边第一个比 X 大的元素的左侧范围内的最大值. 
</span></span></span><span class="line"><span class="cl"><span class="cm">        X 的父节点：是 X 左边第一个比它大的元素 和 X 右边第一个比它大的元素 中值较小的那一个. 如果它两边都没有比它大的, 那它就是整个树的根. 
</span></span></span><span class="line"><span class="cl"><span class="cm">        
</span></span></span><span class="line"><span class="cl"><span class="cm">        恰好符合单调栈的解决问题的特征
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">st</span><span class="p">;</span> <span class="c1">// 存储 TreeNode* 的单调递减栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 遍历输入数组中的每个数字
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 1. 为当前数字创建一个 TreeNode 节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 2. “收编”阶段 (构建树的左子树) ：处理栈内比 cur 小的元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 最后一次循环中的栈顶节点 p 满足: 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 是 cur 右侧, 且在 cur 左边第一个比 cur 大的元素的右侧范围内的最大值.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 总结: 循环中最后一次的栈顶节点 p 是 cur 的 左孩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TreeNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// 获取栈顶节点 p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>               <span class="c1">// 将 p 弹出栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 3. “被收编”阶段 (构建树的右子树) ： 如果栈非空, 意味着栈内有元素, 且大于cur
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 此时的栈顶节点 t 即是 cur左边第一个比它大的元素, cur也是t临近的右侧子数组中的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 总结: 栈顶是cur的爸爸, cur是栈顶的右孩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TreeNode</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// 获取栈顶节点 t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>         <span class="c1">// 将 cur 设置为 t 的右孩子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1">// 4. 入栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 获取根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 树构建完毕, 栈非空, 栈底即是我们的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="cl">        <span class="c1">// 为什么非空? 为什么栈底是我们的根节点?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 我们维护的栈是单调递减栈, 维护体现在while循环中的pop中.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 根节点一旦入栈后, 将不会再遇到比它更大的元素（因为它已经是最大),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 因此它将永远不会被弹出, 并最终留在栈中, 沉到栈底.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 所以栈一定非空 且 栈底元素即为树的根节点.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// 初始化 root 为 nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">root</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">                <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// 初始时 root 指向栈顶（可能是根, 也可能是根的右子孙）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 循环弹出, 直到栈中只剩一个元素（根节点）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">root</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// 更新 root 为新的栈顶（向栈底移动）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">root</span><span class="p">;</span> <span class="c1">// 返回最终的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="19_递归做法_最大二叉树_leetcode_654">19_递归做法_最大二叉树_leetcode_654
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 采取左闭右开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">constructMaximumBinaryTree_help</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                              <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1.终止条件, 数组为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2.寻找最大值及其索引, 这里时间复杂度有点高, 特别是递归多次的话, 能否优化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">max_index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">max</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">max_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3.创建节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">max</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 4.分割数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 1) 左子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">start_left</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">end_left</span> <span class="o">=</span> <span class="n">max_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2) 右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">start_right</span> <span class="o">=</span> <span class="n">max_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">end_right</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5.递归处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="n">constructMaximumBinaryTree_help</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">start_left</span><span class="p">,</span> <span class="n">end_left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="n">constructMaximumBinaryTree_help</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">start_right</span><span class="p">,</span> <span class="n">end_right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">constructMaximumBinaryTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">constructMaximumBinaryTree_help</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="21_合并二叉树_leetcode_617">21_合并二叉树_leetcode_617
</h2><p><strong>问题描述</strong>：给定两棵二叉树 <code>root1</code> 和 <code>root2</code>，将它们合并成一棵新二叉树。合并规则是：如果两个节点重叠，则将它们的值相加作为新节点的值；否则，不为空的节点将作为新树的节点。</p>
<h3 id="我们遇到的问题与解决方案">我们遇到的问题与解决方案
</h3><ol>
<li>
<p><strong>最初代码的编译错误</strong>：</p>
<ul>
<li><strong>我们的问题</strong>：函数 <code>mergeTrees</code> 编译不通过，提示 <code>Non-void function does not return a value in all control paths</code> (非 <code>void</code> 函数并非在所有控制路径都返回值)。</li>
<li><strong>根本原因</strong>：在 <code>root1</code> 和 <code>root2</code> 都不为 <code>nullptr</code> 的情况下，我们执行了 <code>root1-&gt;val += root2-&gt;val;</code> 和递归调用，但<strong>缺少了最终的 <code>return root1;</code> 语句</strong>。C++ 编译器要求所有非 <code>void</code> 函数在其所有可能的执行路径上都必须有 <code>return</code> 语句。</li>
<li><strong>解决方案</strong>：在完成当前节点的合并和子树的递归连接后，明确 <code>return root1;</code>。</li>
</ul>
</li>
<li>
<p><strong>对 <code>return</code> 语句位置的理解</strong>：</p>
<ul>
<li><strong>我们的疑问</strong>：“<code>return</code> 好像一般放在终止条件那里”。</li>
<li><strong>解释与澄清</strong>：
<ul>
<li>对于**“自底向上”**的递归（例如计算树高、统计节点数），通常每个分支（包括基本情况和递归情况）都会返回一个值。</li>
<li>对于**“自顶向下”**的递归（例如收集所有路径），如果函数返回 <code>void</code>，终止条件就是 <code>return;</code>。</li>
<li><strong>本题 (<code>mergeTrees</code>) 属于“自顶向下修改树结构”并同时“返回 <code>TreeNode*</code>”的混合模式</strong>。因此，它在基本情况 (<code>root1 == nullptr</code> 或 <code>root2 == nullptr</code>) 处有 <code>return</code>，在处理完当前层逻辑并连接子树后，也需要 <code>return</code> 当前层修改后的根节点 (<code>root1</code>)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="最终代码逻辑递归">最终代码逻辑（递归）
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">mergeTrees</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root1</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 终止条件 / 基本情况
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">root1</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">root2</span><span class="p">;</span> <span class="c1">// 如果 root1 为空，直接返回 root2（可能为null，也可能是子树）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">root2</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">root1</span><span class="p">;</span> <span class="c1">// 如果 root2 为空，而 root1 不为空，返回 root1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 单层递归逻辑 / 处理当前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果 root1 和 root2 都不为空，则合并当前节点的值 (原地修改 root1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+=</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 递归合并子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 相信递归会正确返回合并后的左/右子树根节点，并连接到 root1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">root1</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="p">(</span><span class="n">root1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">root2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 返回当前合并后的树的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">root1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="22_二叉搜索树中的搜索_leetcode_700">22_二叉搜索树中的搜索_leetcode_700
</h2><p><strong>问题描述</strong>：给定二叉搜索树（BST）的根节点和一个值 <code>val</code>，在 BST 中找到值为 <code>val</code> 的节点。如果节点存在，返回其子树；如果不存在，返回 <code>nullptr</code>。</p>
<h3 id="我们遇到的问题与解决方案-1">我们遇到的问题与解决方案
</h3><p><strong>未充分利用 BST 特性</strong>：
* <strong>我们的最初尝试</strong>：我们最初的代码同时递归搜索了左右子树，像遍历普通二叉树一样。</p>
<pre><code>    ```cpp
    // ...
    TreeNode *left = searchBST(root-&gt;left, val);
    TreeNode *right = searchBST(root-&gt;right, val);
    if (left == nullptr) return right;
    // ... (错误示范)
    ```

* **根本原因**：没有利用 BST 的核心定义（左子树 &lt; 根 &lt; 右子树）。这种方法退化成了 $O(N)$ 的通用二叉树搜索，浪费了 BST 的 $O(\log N)$ 优势。
* **解决方案**：在每个节点，根据 `root-&gt;val` 与 `val` 的比较结果，**只向一个方向（左或右）递归**。这实现了**剪枝**，显著提高效率。
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 1. 参数: 当前树的根节点, 参考值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2. 返回值: 匹配到了的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 3. 终止条件:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 1) 空节点, 返回空节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 2) 根节点匹配对应的值, 返回对应节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 4.单层递归逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">searchBST</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 3.终止条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">searchBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">searchBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="nf">searchBST_traversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 迭代法遍历, 利用BST的特性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// val &gt; root-&gt;val
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="23_验证二叉搜索树_leetcode_98">23_验证二叉搜索树_leetcode_98
</h2><p>/*</p>
<h3 id="1-问题描述与核心定义">1. 问题描述与核心定义
</h3><p>本题要求判断给定的二叉树是否是一个<strong>有效的二叉搜索树 (Binary Search Tree, BST)</strong>。</p>
<p><strong>BST 的核心定义（标准教科书版本，不允许重复值）：</strong></p>
<ul>
<li>对于任意节点 <code>N</code>：
<ul>
<li>其<strong>左子树</strong>中所有节点的值都<strong>严格小于</strong> <code>N-&gt;val</code>。</li>
<li>其<strong>右子树</strong>中所有节点的值都<strong>严格大于</strong> <code>N-&gt;val</code>。</li>
</ul>
</li>
<li>左右子树本身也必须是有效的 BST。</li>
</ul>
<h3 id="2-核心思路中序遍历的单调性">2. 核心思路：中序遍历的单调性
</h3><p>判断一个二叉树是否为 BST 的最经典、最直观且高效的方法是利用其<strong>中序遍历</strong>的特性：</p>
<ul>
<li><strong>一个有效的 BST 的中序遍历结果，必然是</strong>严格递增<strong>的（从小到大排序）。</strong></li>
<li>因此，我们可以对树进行中序遍历，并在遍历过程中，检查当前节点的值是否严格大于前一个节点的值。</li>
</ul>
<h3 id="3-解法选择与实现方式">3. 解法选择与实现方式
</h3><p>我们主要探讨了基于<strong>递归中序遍历</strong>的方法。</p>
<h4 id="递归中序遍历--辅助变量-最优解">递归中序遍历 + 辅助变量 (最优解)
</h4><p><strong>基本思路</strong>：
执行中序遍历 (左 -&gt; 根 -&gt; 右)。在访问到每个节点（“根”部分）时，将其值与<strong>前一个</strong>已经访问过的节点的值进行比较。</p>
<p><strong>关键挑战与解决方案：</strong></p>
<ol>
<li>
<p><strong>“前一个节点”状态的保存</strong>：</p>
<ul>
<li><strong>我们的洞察</strong>：我们正确地意识到，<code>pre</code> (前一个节点) 的状态需要<strong>跨越递归调用</strong>进行保存，因此不能作为局部变量定义在函数体内。</li>
<li><strong>解决方案</strong>：将 <code>pre</code> 定义为 <code>Solution</code> 类的<strong>成员变量</strong>（<code>TreeNode *pre = nullptr;</code>）。在每次 <code>isValidBST</code> 外部调用时（例如在 LeetCode 平台对每个测试用例调用时），需要确保 <code>pre</code> 被重置为 <code>nullptr</code>，以避免多个测试用例之间状态相互影响。</li>
</ul>
</li>
<li>
<p><strong>严格递增的判断</strong>：</p>
<ul>
<li><strong>我们的质疑</strong>：我们最初的判断条件可能只检查 <code>pre-&gt;val &gt; root-&gt;val</code>，没有考虑到相等的情况。我们后续也精确地提出“BST 中 <code>pre</code> 和 <code>root</code> 的值不能相等”。</li>
<li><strong>解决方案</strong>：确保判断条件捕获<strong>所有违反严格递增的情况</strong>。最严谨的条件是 <code>root-&gt;val &lt;= pre-&gt;val</code>（如果 <code>pre</code> 不为 <code>nullptr</code>）。这会捕获 <code>pre</code> 大于 <code>root</code> 或 <code>pre</code> 等于 <code>root</code> 的所有不合法情况。</li>
</ul>
</li>
<li>
<p><strong>递归剪枝与返回时机</strong>：</p>
<ul>
<li><strong>我们的问题</strong>：我们最初的代码在左子树验证失败时，没有立即返回 <code>false</code>，而是继续了后续比较和右子树的递归。</li>
<li><strong>解决方案</strong>：在每次递归调用子树（<code>isValidBST(root-&gt;left)</code> 或 <code>isValidBST(root-&gt;right)</code>）之后，如果子树的验证结果为 <code>false</code>，<strong>立即返回 <code>false</code></strong>。这能有效剪枝，避免不必要的计算。</li>
</ul>
</li>
</ol>
<h4 id="最终代码逻辑-递归中序遍历符合标准-bst-定义">最终代码逻辑 (递归中序遍历，符合标准 BST 定义)
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">  </span><span class="c1">// (通常用于迭代解法，这里用于确保包含，但不直接使用)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"> </span><span class="c1">// (通常用于数组，这里用于确保包含，但不直接使用)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// TreeNode 结构体定义 (LeetCode 通常会提供)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">TreeNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// pre 指针用于保存中序遍历中当前节点的前一个节点。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 它是类成员变量，确保在递归调用之间保持状态。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 每次调用公共接口 isValidBST 时，需要确保其被重置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">pre</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断二叉树是否为有效的二叉搜索树 (BST)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">isValidBST</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 1. 终止条件 / 基本情况 (Base Case)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 空节点被认为是有效的 BST 子树 (因为没有节点可以违反规则)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 2. 递归左子树 (中序遍历的 &#34;左&#34; 部分)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果左子树本身不是有效的 BST，那么整个树都不是，立即返回 false (剪枝，提高效率)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isValidBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 3. 处理当前节点 (中序遍历的 &#34;根&#34; 部分)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 检查当前节点的值是否严格大于前一个节点的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果 pre 不为空 (即不是中序遍历的第一个节点)，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 并且当前节点的值不严格大于 pre 的值 (即 root-&gt;val &lt;= pre-&gt;val)，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 则违反 BST 的严格递增性质（包括值相等的情况）。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pre</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">pre</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 更新前一个节点为当前节点 (为下一个节点的比较做准备)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pre</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 4. 递归右子树 (中序遍历的 &#34;右&#34; 部分)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 如果右子树本身不是有效的 BST，那么整个树都不是，立即返回 false (剪枝)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isValidBST</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 5. 如果左子树、当前节点检查、右子树都通过了验证，则整个子树是有效的 BST
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
</section>


    <footer class="article-footer">
    

    </footer>


    
    <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
	const mainArticleElement = document.querySelector(".main-article");
        renderMathInElement(mainArticleElement, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>

    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day18/">
        
        
            <div class="article-image">
                
                    <img src="/Sophomoresty.io/img/code.jpg" loading="lazy" data-key="" data-hash="/Sophomoresty.io/img/code.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">代码随想录_day18</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day16/">
        
        
            <div class="article-image">
                
                    <img src="/Sophomoresty.io/img/code.jpg" loading="lazy" data-key="" data-hash="/Sophomoresty.io/img/code.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">代码随想录_day16</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day15/">
        
        
            <div class="article-image">
                
                    <img src="/Sophomoresty.io/img/code.jpg" loading="lazy" data-key="" data-hash="/Sophomoresty.io/img/code.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">代码随想录_day15</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day14/">
        
        
            <div class="article-image">
                
                    <img src="/Sophomoresty.io/img/code.jpg" loading="lazy" data-key="" data-hash="/Sophomoresty.io/img/code.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">代码随想录_day14</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day13/">
        
        
            <div class="article-image">
                
                    <img src="/Sophomoresty.io/img/code.jpg" loading="lazy" data-key="" data-hash="/Sophomoresty.io/img/code.jpg"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">代码随想录_day13</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="Sophomoresty/Sophomoresty.io"
    data-repo-id="R_kgDOOq9B4A"
    data-category="Announcements"
    data-category-id="DIC_kwDOOq9B4M4CqN6o"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="github-light"
    data-lang="en"
    data-loading=""
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector("iframe.giscus-frame");
        if (giscus) {
            giscus.contentWindow.postMessage(
                {
                    giscus: {
                        setConfig: {
                            theme: theme,
                        },
                    },
                },
                "https://giscus.app"
            );
        }
    }

    (function () {
        addEventListener("message", (e) => {
            if (event.origin !== "https://giscus.app") return;
            handler();
        });
        window.addEventListener("onColorSchemeChange", handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('github-light');
            } else {
                setGiscusTheme('github-dark');
            }
        }
    })();
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy;
        
        2025 靝Sol
    </section>

    <section class="powerby">
        
        去码头整点薯条 <br />
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener"
                data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>

</footer>

    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/Sophomoresty.io/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
