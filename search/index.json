[{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n1_反转字符串I_leetcode_344 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;vector\u0026gt; using namespace std; class Solution { private: void swapString(vector\u0026lt;char\u0026gt; \u0026amp;s, int left, int right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; } public: void reverseString(vector\u0026lt;char\u0026gt; \u0026amp;s) { int left, right; for (left = 0, right = s.size() - 1; left \u0026lt; right; left++, right--) { swapString(s, left, right); } } }; 2_反转字符串II_leetcode_541 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;string\u0026gt; using namespace std; class Solution { public: void swapString(string \u0026amp;s, int left, int right) { char temp = s[left]; s[left] = s[right]; s[right] = temp; } // 反转left到right的字符串, 是闭区间 void reverseString(string \u0026amp;s, int left, int right) { for (; left \u0026lt; right; left++, right--) { swapString(s, left, right); } } string reverseStr(string s, int k) { for (int i = 0; i \u0026lt; s.size(); i += 2 * k) { // 反转前k个, 条件是i+k不超出s.size() if (i + k \u0026lt; s.size()) { this-\u0026gt;reverseString(s, i, i + k - 1); } // 如果剩下的没有k个, 反转剩下的 else { this-\u0026gt;reverseString(s, i, s.size() - 1); } } return s; } }; 3_替换数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string s; while (cin \u0026gt;\u0026gt; s) { int old_len = s.size(); int count = 0; // 1.统计字符中数字出现的次数 for (auto i : s) { if (i \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; i \u0026lt;= \u0026#39;9\u0026#39;) { count++; } } // 2.每个数字都要替换成number, 也就以为着数组增加5*count s.resize(old_len + 5 * count); int new_len = s.size(); // 用双指针遍历 int left, right; for (left = old_len - 1, right = new_len - 1; left \u0026gt; -1; left--) { // left的内容是数字 if (s[left] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[left] \u0026lt;= \u0026#39;9\u0026#39;) { s[right--] = \u0026#39;r\u0026#39;; s[right--] = \u0026#39;e\u0026#39;; s[right--] = \u0026#39;b\u0026#39;; s[right--] = \u0026#39;m\u0026#39;; s[right--] = \u0026#39;u\u0026#39;; s[right--] = \u0026#39;n\u0026#39;; } // left的内容是非数字 else { s[right--] = s[left]; } } cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } } ","date":"2025-05-22T12:11:29+08:00","image":"https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg","permalink":"https://Sophomoresty.github.io/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day7/","title":"代码随想录_day7"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n最近复习压力比较大, 没有时间做笔记和额外训练, 目前只做了大概的最优解, 后面二轮的时候要补充完\n5_四数相加II_leetcode_454 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: // // 哈希法 int fourSumCount(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2, vector\u0026lt;int\u0026gt; \u0026amp;nums3, vector\u0026lt;int\u0026gt; \u0026amp;nums4) { // 初始定义map unordered_map\u0026lt;int, int\u0026gt; res_map; // 遍历数组1,2, 对map进行初始化 for (auto a : nums1) { for (auto b : nums2) { auto it = res_map.find(a + b); // unordered_map在创建未存在的键的时候会自动初始赋值为0, // 所以不需要手动初始化 不存在则value赋值为1 // 存在则value++ res_map[a + b]++; } } // 定义符合条件的四元组个数 int count = 0; // 遍历数组3,4,在map中找对应的target的value for (auto c : nums3) { for (auto d : nums4) { int target = 0 - (c + d); auto it = res_map.find(target); // 找到的情况下 if (it != res_map.end()) { count += res_map[target]; // } } } return count; } }; 6_赎金信_leetcode_383 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: bool canConstruct(string ransomNote, string magazine) { // ransomNote 和 magazine 由小写英文字母组成 // 可以用长度26的数组作为哈希表, magazing出现过的字符, 对应值+1, // for循环遍历ransomNote, 看哈希表中有没有对应的字符 vector\u0026lt;int\u0026gt; res_vec(26, 0); for (auto i : magazine) { res_vec[i - \u0026#39;a\u0026#39;]++; } for (auto i : ransomNote) { if (res_vec[i - \u0026#39;a\u0026#39;] \u0026gt; 0) { res_vec[i - \u0026#39;a\u0026#39;]--; } else { return false; } } return true; } }; int main() { string ransomNote = \u0026#34;aa\u0026#34;; string magazine = \u0026#34;aab\u0026#34;; Solution sol; bool flag = sol.canConstruct(ransomNote, magazine); // canConstruct(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) -\u0026gt; false printf(\u0026#34;canConstruct(\\\u0026#34;%s\\\u0026#34;, \\\u0026#34;%s\\\u0026#34;) -\u0026gt; %s\\n\u0026#34;, ransomNote.c_str(), magazine.c_str(), flag ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;); return 0; } 7_三数之和_leetcoe_15 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 0. 处理边界情况：如果元素数量不足3个，直接返回空 if (nums.size() \u0026lt; 3) { return {}; } // 最后返回的值是多个三元组, 三元组的内容设为[i,j,k], ijk的和为0, // 且ijk的序号不能相同, 三元组不能重复 // 对数组进行排序 sort(nums.begin(), nums.end()); // 如果最小值大于0, 也就以为三元组不可能存在, 返回空; if (nums[0] \u0026gt; 0) { return {}; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res_vec; // 对数组进行遍历 // 使用i, left, right就是为了避免序号相同 // 对i, left, right去重, 是为了避免三元组重复 for (int i = 0; i \u0026lt; nums.size() - 2; i++) { // 进入循环前需要去i的重, 重复的情况下结束本次循环 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } // 定义left和right指针 int left = i + 1; int right = nums.size() - 1; // right指针永远指向末尾会不会重复? 不会, 因为i去重了 // 因为序号不能相同, 也就是退出循环时, right =left while (right \u0026gt; left) { int temp = nums[i] + nums[left] + nums[right]; if (temp \u0026gt; 0) { right--; } else if (temp \u0026lt; 0) { left++; } // temp = 0; else { res_vec.push_back({nums[i], nums[left], nums[right]}); // 当i,left,right的值刚好为0时, 此时i是固定的, // 如果只动right或则left, 是找不到值的 也就是这种情况下, // 为了找继续可能存在的值, left和right都必须收缩 do { left++; } // 对left和while去重, 必须用循环处理, 退出条件是前后不相等, // 这有可能导致right和left错位 // 综上, 循环条件是前后相等 且 left \u0026lt; right while (nums[left] == nums[left - 1] \u0026amp;\u0026amp; left \u0026lt; right); do { right--; } while (nums[right] == nums[right + 1] \u0026amp;\u0026amp; left \u0026lt; right); } } } return res_vec; } }; 8_四数之和_leetcode_18 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; one_fourSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res_vec; // vector初始化的数组为空 sort(nums.begin(), nums.end()); // 0.处理边界情况 if (nums.size() \u0026lt; 4) { return {}; } // i最多到nums.size()-4 for (int i = 0; i \u0026lt; nums.size() - 3; i++) { // 1.1 i剪枝 // target大于0的情况下, nums[i]如果大于target, 则无解, // 而且意味着后续的i也无解, 所以要结束循环, 而不是结束本次循环 // target \u0026gt;= 0 , nums[i]可否等于target // target =0的情况下, num[i]=target=0,后续的值也可以找到四元组, // 比如{0,0,0,0}, 因为数组单调不减 // 总结 // target=0 , nums[i] \u0026gt; target // target \u0026gt;0的情况, nums[i] \u0026gt;=target if (target == 0 \u0026amp;\u0026amp; nums[i] \u0026gt; target || target \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= target) { break; } // 1.2 i去重 // i重复的情况下, 结束本次循环 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; nums.size() - 2; j++) { // 2.1 j 剪枝 // 在有i的基础上, 如果targe \u0026gt;= 0, nums[i] + nums[j] \u0026gt;= target // \u0026gt;=0 ,也就意味着不可能是目标的四元组 if (target == 0 \u0026amp;\u0026amp; nums[i] + nums[j] \u0026gt; target || target \u0026gt; 0 \u0026amp;\u0026amp; nums[i] + nums[j] \u0026gt;= target) { break; } // 2.2 j去重 // j \u0026gt; 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) // 这个去重逻辑有问题,i和j的值可以相等 // 实际上这里要避免的是i和j同时和上一轮的相同 // 也就是结束循环的条件是j\u0026gt;1, i和上一轮的相同且j和上一轮相同 // i的初始值是0, j的初始值是1, 也就是j要大于1 if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } int left = j + 1; int right = nums.size() - 1; while (left \u0026lt; right) { long long temp = (long long)nums[i] + nums[j] + nums[left] + nums[right]; if (temp \u0026gt; target) right--; else if (temp \u0026lt; target) left++; // temp=target else { // 添加四元组 res_vec.push_back( {nums[i], nums[j], nums[left], nums[right]}); // 去重 do { left++; } while (nums[left] == nums[left - 1] \u0026amp;\u0026amp; left \u0026lt; right); do { right--; } while (nums[right] == nums[right + 1] \u0026amp;\u0026amp; left \u0026lt; right); }; } } } return res_vec; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res_vec; if (nums.size() \u0026lt; 4) return res_vec; sort(nums.begin(), nums.end()); size_t length = nums.size(); for (int i = 0; i \u0026lt; length - 3; i++) { // 1.剪枝 // 最小的组合都大于target ,无解, break if ((long long)nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] \u0026gt; target) { break; } // 初始值加最大的三个组合都小于target, 说明当前值肯定不行 if ((long long)nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] \u0026lt; target) { continue; } if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; length - 2; j++) { if ((long long)nums[i] + nums[j] + nums[j + 1] + nums[j + 2] \u0026gt; target) { break; } if ((long long)nums[i] + nums[j] + nums[length - 2] + nums[length - 1] \u0026lt; target) { continue; } if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) { continue; } int left = j + 1; int right = nums.size() - 1; while (left \u0026lt; right) { long long sum = (long long)nums[i] + nums[j] + nums[left] + nums[right]; if (sum \u0026gt; target) { right--; } else if (sum \u0026lt; target) { left++; } else { res_vec.push_back( {nums[i], nums[j], nums[left], nums[right]}); do { left++; } while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left - 1]); do { right--; } while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right + 1]); } } } } return res_vec; } }; int main() { vector\u0026lt;int\u0026gt; nums = {-2, -1, -1, 1, 2, 2}; int target = 0; Solution sol; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res_vec = sol.fourSum(nums, target); for (auto i : res_vec) { cout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;; for (auto j : i) { cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } ","date":"2025-05-21T17:37:44+08:00","image":"https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg","permalink":"https://Sophomoresty.github.io/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day6/","title":"代码随想录_day6"},{"content":"代码仓库: https://github.com/Sophomoresty/Algorithm_Exercises.git\n1_有效的字母异位词_leetcode_242 未完成的任务 对unicode的情况进行处理\n1. 暴力解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 暴力解法 // 遍历s,t两个数组, 对s中每一个字符, 在t中找到对应的字符, // 为了防止重复匹配到已匹配的字符, 需要对匹配的字符进行换值, 因此t需要备份, bool baoli_isAnagram(string s, string t) { // 长度不等直接false if (s.length() != t.length()) { return false; } // 因为要对t修改, 提前备份 string t_backup = t; // 定义1个bool值, 表示当前s的字符是否匹配上t了 bool found; for (int i = 0; i \u0026lt; s.length(); i++) { found = false; for (int j = 0; j \u0026lt; t_backup.length(); j++) { // 如果相等的话 if (s[i] == t_backup[j]) { found = true; t_backup[j] = \u0026#39;#\u0026#39;; // 对匹配到的字符进行更替, 防止重复匹配 break; // s的字符已经找到了对应的字符, 没必要找了 } } // s的一个字符在t中没找到, 直接返回false if (found == false) { return false; } } return true; } 2. 数组哈希解法_最优解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 只处理小写字母, 而不是unicode编码, 小写字母的ascii码有26个, // 所以只需要长度为26的数组, 遍历s,t将每个字符映射到数组的索引, 然后++ // 如果数组中的值均为2, 则s,t是字母异位词, 有问题, // 字符串里面的字符可以重复出现, // 也就是出现偶数个才是正确的, 还是有问题, 如果是 aa 和 bb,也会是偶数 // 所以最好的思路是, t中的字符++, s中的字符--, // 如果字符在数组中对应的值为0的话, 也就意味着字符相等 bool isAnagram(string s, string t) { if (s.length() != t.length()) { return false; } vector\u0026lt;int\u0026gt; hash_vec(26); for (int i = 0; i \u0026lt; s.length(); i++) { hash_vec[s[i] - \u0026#39;a\u0026#39;]++; hash_vec[t[i] - \u0026#39;a\u0026#39;]--; } for (int i = 0; i \u0026lt; hash_vec.size(); i++) { if (hash_vec[i] != 0) { return false; } } return true; } 2_两个数组的交集_leetcode_349 1. 暴力解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 用1个额外的数组存储交点 (这个做法是错误的, 数组无法去重) // 空间复杂度o(min(n,m)), 时间复杂度o(n*m) vector\u0026lt;int\u0026gt; baoli_intersection(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2) { unordered_set\u0026lt;int\u0026gt; intersection_set; for (int i = 0; i \u0026lt; nums1.size(); i++) { for (int j = 0; j \u0026lt; nums2.size(); j++) { if (nums1[i] == nums2[j]) { intersection_set.insert(nums1[i]); break; } } } return vector\u0026lt;int\u0026gt;(intersection_set.begin(), intersection_set.end()); } 2. 哈希集合解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 哈希集合解法 vector\u0026lt;int\u0026gt; intersection(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2) { // unordered_set无序, 数值不可以重复, 值不能更改, // 所以存储结果必须单开集合 // 找到长, 短数组 vector\u0026lt;int\u0026gt; nums_short = nums1.size() \u0026lt; nums2.size() ? nums1 : nums2; vector\u0026lt;int\u0026gt; nums_long = nums1.size() \u0026lt; nums2.size() ? nums2 : nums1; unordered_set\u0026lt;int\u0026gt; nums_set(nums_short.begin(), nums_short.end()); unordered_set\u0026lt;int\u0026gt; res_set; for (int num : nums_long) { // 在nums_set中找有没有相同的值, 有则加入 // find的结果 // 1. 找到的情况下返回当前值的迭代器 // 2.没找到的情况下返回nums_set.end() if (nums_set.find(num) != nums_set.end()) { res_set.insert(num); } } return vector\u0026lt;int\u0026gt;(res_set.begin(), res_set.end()); // 1.时间复杂度分析 // 循环中需要遍历长数组, 最坏情况下, 时间复杂度为o(max(n,m)) // 2.空间复杂度分析 // 2.1 将最小数组存入集合中, 空间复杂度o(min(n,m)) // 2.2 res_set用于存放相交的值, 空间复杂度为o(k), k\u0026lt;= o(min(n,m)) // 2.3 最后返回的数组, 空间复杂同为o(k) // 综合来看, 空间复杂度为o(min(n,m)) } 3. 数组+哈希集合_最优解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 最优解 // 由于题目规定了数值仅在0-1000, // 最开始放短数组的值可以放在数组中, 数组的开销小, 能用数组就不要用set, // 使用数字必须在空间确定的情况下, 不确定的情况习, 容易造成空间浪费, // 这种情况下用set 所以存放数值还是必须要放在哈希表中, 因为最后要不重复 vector\u0026lt;int\u0026gt; better_intersection(vector\u0026lt;int\u0026gt; \u0026amp;nums1, vector\u0026lt;int\u0026gt; \u0026amp;nums2) { vector\u0026lt;int\u0026gt; nums_array(1001, 0); unordered_set\u0026lt;int\u0026gt; res_set; // 找到长短数组 vector\u0026lt;int\u0026gt; nums_short = nums1.size() \u0026lt; nums2.size() ? nums1 : nums2; vector\u0026lt;int\u0026gt; nums_long = nums1.size() \u0026lt; nums2.size() ? nums2 : nums1; // 遍历短数组, 用其值作为索引, 出现的情况下+1, 后续判断是否相交, // 即对长数组遍历, 判断其值的索引的值是否为1即可 for (int num : nums_short) { nums_array[num] = 1; } for (int num : nums_long) { if (nums_array[num] == 1) { res_set.insert(num); } } return vector\u0026lt;int\u0026gt;(res_set.begin(), res_set.end()); } 3_快乐数_leetcode_202 1. 哈希集合法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int get_sum(int n) { int sum = 0; while (n) { sum += (n % 10) * (n % 10); n = n / 10; } return sum; } bool isHappy(int n) { unordered_set\u0026lt;int\u0026gt; res_set; int sum; while (true) { sum = get_sum(n); if (sum == 1) { return true; } if (res_set.find(sum) != res_set.end()) { return false; } else { res_set.insert(sum); } n = sum; } } 2. 快慢指针法_最优解 自己最初写的, 写的很繁琐, 没要考虑到fast和slow, 无论是有解还是无解, 最终都要相等, 有解的情况下相等值为1, 无解的情况下相等值非1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 因为无解的情况下, 会陷入循环, 陷入循环的情况下, // 如果快指针和慢指针同时出发, 快指针一定会套圈, 追上慢指针 // 比如 2 -\u0026gt; 4 -\u0026gt; 16 -\u0026gt; 37 -\u0026gt; 58 -\u0026gt; 89 -\u0026gt; 145 -\u0026gt; 42 -\u0026gt; 20 -\u0026gt; 4 // 有解的情况下, 没有循环 比如 // 1 -\u0026gt; 1 -\u0026gt; 1 bool better_isHappy(int n) { int slow, fast; // 初始化 slow = get_sum(n); fast = get_sum(n); fast = get_sum(fast); if (fast == 1) { return true; } // 也就是无解的情况下, 一定会退出循环, 有解的情况下, 快指针一定为1 while (fast != slow) { if (fast == 1) { return true; } slow = get_sum(slow); fast = get_sum(fast); fast = get_sum(fast); } return false; } 参考答案写的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool better_2_isHappy(int n) { int fast, slow; fast = slow = n; // // 初始化 // slow = get_sum(slow); // fast = get_sum(fast); // fast = get_sum(fast); // 快指针和慢指针在哪种情况下都会相遇, 无解的情况下相遇的值不为1, // 有解的情况相遇的值为1 do { slow = get_sum(slow); fast = get_sum(fast); fast = get_sum(fast); } while (fast != slow); return slow == 1; } ; 4_两数之和_leetcode_1 1. 暴力解法 1 2 3 4 5 6 7 8 9 10 11 vector\u0026lt;int\u0026gt; baoli_twoSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 暴力做法 // 遍历嵌套两次 for (int i = 0; i \u0026lt; nums.size(); i++) { for (int j = i + 1; j \u0026lt; nums.size(); j++) { if (nums[i] + nums[j] == target) { return vector\u0026lt;int\u0026gt;{i, j}; } } } } 2. map解法_最优解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 遍历nums数组, 在map中找target-遍历值, // 找到了则输出它们的index // 找不到则在map中存储 遍历值:index unordered_map\u0026lt;int, int\u0026gt; nums_map; for (int i = 0; i \u0026lt; nums.size(); i++) { auto itter = nums_map.find(target - nums[i]); // 找到这个元素的情况下 if (itter != nums_map.end()) { // 返回这对键值对 return vector\u0026lt;int\u0026gt;{nums_map[target - nums[i]], i}; } // 没找到这个元素的情况下 else { nums_map.insert({nums[i], i}); } } // 如果没有找到符合条件的两个数，返回空vector return {}; } ","date":"2025-05-19T19:00:30+08:00","image":"https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg","permalink":"https://Sophomoresty.github.io/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day5/","title":"代码随想录_day5"},{"content":"总结 虚拟头结点的序号记为-1, 头结点记为0\ntail节点, 一直指向最后1个节点\ntail节点更新的情况\n1.链表0个节点, 头部插入 2.尾部插入 3.任意序号插入, 尾部插入\n易错 addAtIndex 没有处理 index \u0026gt; _size 的情况 添加到尾部的条件错误, 添加到尾部的正确条件是 index == _size deleteAtIndex 1.没更新_size 2.temp指针的空间删除后, 要指向空 3.没有考虑删除尾结点的时候, 要更新_tail 4.没有考虑到删除节点后, 链表为空, 要更新_tail\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 // 定义链表 struct LinkNode { int val; struct LinkNode *next; // 构造函数体 LinkNode() : val(0), next(nullptr) {} LinkNode(int x) : val(x), next(nullptr) {} LinkNode(int x, LinkNode *node) : val(x), next(node) {} }; class MyLinkedList { private: int _size; LinkNode *_dummyHead; LinkNode *_tail; public: MyLinkedList() { _size = 0; _dummyHead = new LinkNode(); _tail = _dummyHead; } int get(int index) { // 判断是否有效 index if (index \u0026lt; 0 || index \u0026gt; _size - 1) { return -1; } LinkNode *cur = _dummyHead; for (int i = 0; i \u0026lt;= index; i++) { cur = cur-\u0026gt;next; } return cur-\u0026gt;val; } void addAtHead(int val) { LinkNode *new_node = new LinkNode(val); new_node-\u0026gt;next = _dummyHead-\u0026gt;next; _dummyHead-\u0026gt;next = new_node; if (_size == 0) { _tail = new_node; } _size++; } void addAtTail(int val) { LinkNode *new_node = new LinkNode(val); _tail-\u0026gt;next = new_node; _tail = new_node; _size++; } void addAtIndex(int index, int val) { // 原始错误 // 1. inde\u0026gt;_size, 没有处理 // 2. 添加到尾部的判断错误, 添加到尾部的添加是index==_size if (index \u0026gt; _size) { return; // index \u0026lt;=0 头部插入 } if (index \u0026lt;= 0) { addAtHead(val); return; } // index = _size-1, 不是尾部插入 , 理解错了, _size-1是尾结点, // index = _size-1 插入实际上是后面的逻辑 if (index == _size) { addAtTail(val); return; } // 0 \u0026lt; index \u0026lt; _size LinkNode *cur = _dummyHead; LinkNode *new_node = new LinkNode(val); // 在index处停止 for (int i = 0; i \u0026lt; index; i++) { cur = cur-\u0026gt;next; } new_node-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = new_node; _size++; } void deleteAtIndex(int index) { // 原始错误 // 1.没更新_size // 2.temp指针的空间删除后, 要指向空 // 3.没有考虑删除到尾结点的时候, _tail的更新 // 4.没有考虑到删除后, 链表为空的情况 if (index \u0026lt; 0 || index \u0026gt; _size - 1) { return; } LinkNode *cur = _dummyHead; for (int i = 0; i \u0026lt; index; i++) { cur = cur-\u0026gt;next; } LinkNode *temp = cur-\u0026gt;next; // 删除的是尾结点 if (temp == _tail) { _tail = cur; } cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; delete temp; temp = nullptr; _size--; // 删除后如果长度为0 if (_size == 0) { _tail = _dummyHead; } } ~MyLinkedList() { LinkNode *current = _dummyHead; while (current != nullptr) { LinkNode *next = current-\u0026gt;next; // 先保存下一个节点的地址 delete current; // 删除当前节点 current = next; // 移动到下一个节点 } _dummyHead = nullptr; // 删除完后，将头指针置空 _tail = nullptr; // 尾指针也置空 _size = 0; // 尺寸归零 } }; ","date":"2025-05-18T16:41:36+08:00","image":"https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg","permalink":"https://Sophomoresty.github.io/Sophomoresty.io/p/leetcode_707_%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8_%E7%94%A8size%E5%92%8Ctail/","title":"leetcode_707_设计链表_用size和tail"},{"content":"双指针法1(卡哥思路) 思路和总结 把链表想象为一根绳子, 让绳子右端点对齐\n1.分别遍历A,B两个链表, 得出A,B的长度 2.让长链表的初始指针移动到, 和短链表初始指针对齐\n本次题暴露了自己循环体理解的问题, while和for是等价的\n写好循环体, 一般是通过对应关系去写条件\n对应关系: 本次循环体刚进来的判别的对象 和 对应的变化值\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { // 处理长度为0的情况 if (headA == nullptr || headB == nullptr) { return nullptr; } // 1. 计算链表长度 // 链表的索引从0开始 ListNode *curA, *curB; curA = headA; int len_A, len_B; len_A = 0; len_B = 0; // curA是判别对象 while (curA != nullptr) { curA = curA-\u0026gt;next; len_A++; // 索引 0 -\u0026gt; 长度 1, 正确 } curB = headB; while (curB != nullptr) { curB = curB-\u0026gt;next; len_B++; } // 2. 重置指针 curA = headA; curB = headB; // 3. 将长链表的指针向前移动长度差的步数进行对齐 if (len_A \u0026gt; len_B) { // 从0移动到LA-LB,步数为LA-LB for (int i = 1; i \u0026lt;= (len_A - len_B); i++) { curA = curA-\u0026gt;next; } } if (len_A \u0026lt; len_B) { for (int i = 1; i \u0026lt;= (len_B - len_A); i++) { curB = curB-\u0026gt;next; } } // 现在curA和curB在同一起点, 同时出发 while (curA != nullptr \u0026amp;\u0026amp; curB != nullptr) { if (curA == curB) { return curA; } curA = curA-\u0026gt;next; curB = curB-\u0026gt;next; } return nullptr; } }; 双指针法2 思路和总结 设A独有的长度为a, 和B相同的部分为c; 设B独有长度为b, 和A相同的部分为c; 让A,B链表拼接在一起.\n1 A,B有相同的部分\nurA 从 A 端出发, curB 从 B 端出发, curA 第一次到达相同部分, 移动的距离是a-1 curA 第二次到达相同部分, 移动的距离是a+c-1+b curB 第一次到达相同的部分, 移动的距离是b-1 curB 第二次到达相同的部分, 移动的距离是b+c-1+a 即A,B有相同的部分, 它们一定会移动相同的距离 a+b+c-1, 遇到第一个相等的对象.\n2 A, B没有相同的部分\nA,B会走完全程, 遇到1个相等的对象 nullptr\n总结: 通过让两个指针走的总路程相等(LA+LB)，它们一定会在某个时刻相遇。 而这个相遇点，必然是它们第一次同时到达的、在两条“加长”路径上具有相同相对位置的那个点，也就是相交点（如果存在的话），或者最终的 nullptr（如果不相交的话）。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (!headA || !headB) return nullptr; ListNode *curA, *curB; curA = headA; curB = headB; // 循环退出条件, curA, curB相等 while (curA != curB) { curA = curA == nullptr ? headB : curA-\u0026gt;next; curB = curB == nullptr ? headA : curB-\u0026gt;next; } return curA; } }; 暴力解法 总结 原始错误\n循环嵌套需要初始化curB, 此前没有初始化curB\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { // 0个节点 if (headA == nullptr || headB == nullptr) { return nullptr; } // 暴力解法, 同时遍历A和B, 有个相等时即return ListNode *curA = headA; while (curA != nullptr) { ListNode *curB = headB; // 注意要初始化 while (curB != nullptr) { if (curA == curB) { return curA; } curB = curB-\u0026gt;next; } curA = curA-\u0026gt;next; } return nullptr; } }; ","date":"2025-05-18T16:22:06+08:00","image":"https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg","permalink":"https://Sophomoresty.github.io/Sophomoresty.io/p/leetcode_%E9%9D%A2%E8%AF%95%E9%A2%98_0207_%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/","title":"Leetcode_面试题_0207_链表相交"},{"content":"今日BB 前天在配置wsl环境和博客, 昨天只做了区间和开发商问题, 链表的任务全部拖到今天解决了, 花了大半天写完了, 链表还剩链表相交, 今天没时间做了.\n数组收获 开发商题目中最大收获就是在处理行/列分割的时候, 可以用行, 列前缀和处理.\n我最原始的思路是n行m列矩阵, 如果按行分割, 这里约定被分割的行及其前面的都属于前一部分的, 列分割同理, 那行分割的序号可以从1到n-1, 按照矩阵的索引来说, 就是 0 到 n-2.\n比如3行的矩阵\n行分割索引为0, 则分割为[0], [1,2] 行分割索引为1, 则分割为[0,1],[2] 同理列分割的索引可以从0到n-2.\n想到这里的时候, 我是想把分割后的差值的绝对值求出来, 最后一起求最小值, 但是非常繁琐. 看了卡哥的代码豁然开朗.\n1 2 3 4 5 6 7 8 9 10 11 12 int result = INT_MAX; int horizontalCut = 0; for (int i = 0; i \u0026lt; n; i++) { horizontalCut += horizontal[i]; result = min(result, abs(sum - horizontalCut - horizontalCut)); } int verticalCut = 0; for (int j = 0; j \u0026lt; m; j++) { verticalCut += vertical[j]; result = min(result, abs(sum - verticalCut - verticalCut)); } cout \u0026lt;\u0026lt; resu horizontal 和 vertical是前面算出来的矩阵的每行, 毎列的和. sum是矩阵所有元素的和, 这里最开始看不懂的是horizontalCut干嘛的.\n实际上思路和我们前面是一样的, 要求分割后的差值.\ni=0, horizontalCut为第1行的和, 而sum - horizontalCut即为2,3行的和.\n所以i=0时, sum - horizontalCut - horizontalCut即是分割索引为0时, 上下两部分的差值.\n这里的for循环即是把所有分割的可能的差值求出来, 每次都在更新result.\n美中不足的是, i \u0026lt; n不是最精确的范围:\ni = n-1时, horizontal是全部行的和, 这个分割的差值显然是0, 逻辑完善的话, for循环条件应为 i \u0026lt; n - 1.\n链表收获 今天链表比较欠缺的部分是 设计链表 是用不含size属性实现的, 后续要做含size属性的以及双链表.\n之前以为数据结构学过链表, 这里没啥问题. 结果在设计链表的边界处理, 犯了很多错误:\n在链表尾处添加节点, 没有考虑到空节点的情况 两两交换链表中的节点和环形链表中都用了步长为2的指针, 这里最需要注意的就是快指针的边界处理, 很容易操作空指针.\n","date":"2025-05-17T20:31:55+08:00","image":"https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg","permalink":"https://Sophomoresty.github.io/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day4_%E9%93%BE%E8%A1%A8/","title":"代码随想录_day4_链表"},{"content":"今日收获 基础题1-6都做完了, 比想象中的简单. 今天学习到最多的就是力扣编号34的, 在排序数组中查找元素的第一个和最后一个位置.\n我原本以为这个和二分查找一样简单, 但发现这个是用二分查找边界. 和卡哥在二分查找的循环变量不同, 思考了2个小时才搞懂, 特此记录下笔记.\n二分查找边界思路 左边界即数组中第1个大于等于target的值, 右边界即数组中第1个大于target的值.\n以二分查找右边界为例, 我们这里采用的循环不变量是[0, left), [right,n).\n这里的n即为数组长度, 采用左闭右开的方式.\n按照循环不变量的思路, 初始化left=0, right=nums.size(). 循环结束条件是left \u0026lt; right.\n精彩的地方来了, 我们如何查找到右边界呢?\n我们只要保证\n[0, left)的数组值严格小于等于target\n[right,n)的值严格大于target 然后不断扩大它们的范围, 直至left=right. 它们相等的值左边小于target, 而这个值本身又大于等于target, 故得出它是第一个大于target的值, 即查找到右边界了, 以上都是建立在target在数组中的.\n如果不在数组中呢?\n1.target在数组的左侧外 2.target在数组的右侧外 3.targe在数组中, 但数组中没有target的这个值\n带入思考, 发现依然能够得出正确的值, 1的右边界索引为0, 2的右边索引为n, 3的右边界索引即为第1个大于target的值的索引.\n左边界的思路同理, 只要保证\n[0, left)的数组值严格小于target\n[right,n)的值严格大于等于target\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left_border = LeftBorder(nums, target); if (left_border == int(nums.size()) || nums[left_border] != target) { return {-1, -1}; } int right_border = RightBoreder(nums, target) - 1; return {left_border, right_border}; } private: int RightBoreder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 缩小区间找第一个大于target的值 int left, right, mid; right = int(nums.size()); left = 0; while (left \u0026lt; right) // [right,n-1)的值严格大于targt // [0, left)的值严格小于等于target // 最后left==right { mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid; } // nums[mid] \u0026lt;= target // 因为left处于开的位置, 已知mid\u0026lt;=target, 故left = mid+1 else { left = mid + 1; // } } return left; } int LeftBorder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left, right, mid; left = 0; right = int(nums.size()); while (left \u0026lt; right) { mid = left + (right - left) / 2; if (nums[mid] \u0026gt;= target) { right = mid; } // nums[mid] \u0026lt; target else { left = mid + 1; } } return left; } }; int main() { vector\u0026lt;int\u0026gt; nums = {5,7,7,8,8,10}; int target = 8; Solution s; vector\u0026lt;int\u0026gt;result = s.searchRange(nums,target); cout \u0026lt;\u0026lt;\u0026#34;Result for \u0026#34;\u0026lt;\u0026lt; target \u0026lt;\u0026lt; \u0026#34;: [\u0026#34; \u0026lt;\u0026lt; result[0] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; result[1] \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-16T15:39:59+08:00","image":"https://Sophomoresty.github.io/Sophomoresty.io/img/code.jpg","permalink":"https://Sophomoresty.github.io/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day_1_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%BE%B9%E7%95%8C/","title":"代码随想录_day_1_二分查找边界"}]