[{"content":"今日收获 基础题1-6都做完了, 比想象中的简单. 今天学习到最多的就是力扣编号34的, 在排序数组中查找元素的第一个和最后一个位置.\n我原本以为这个和二分查找一样简单, 但发现这个是用二分查找边界. 和卡哥在二分查找的循环变量不同, 思考了2个小时才搞懂, 特此记录下笔记.\n二分查找边界思路 左边界即数组中第1个大于等于target的值, 右边界即数组中第1个大于target的值.\n以二分查找右边界为例, 我们这里采用的循环不变量是[0, left), [right,n).\n这里的n即为数组长度, 采用左闭右开的方式.\n按照循环不变量的思路, 初始化left=0, right=nums.size(). 循环结束条件是left \u0026lt; right.\n精彩的地方来了, 我们如何查找到右边界呢?\n我们只要保证\n[0, left)的数组值严格小于等于target\n[right,n)的值严格大于target 然后不断扩大它们的范围, 直至left=right. 它们相等的值左边小于target, 而这个值本身又大于等于target, 故得出它是第一个大于target的值, 即查找到右边界了, 以上都是建立在target在数组中的.\n如果不在数组中呢?\n1.target在数组的左侧外 2.target在数组的右侧外 3.targe在数组中, 但数组中没有target的这个值\n带入思考, 发现依然能够得出正确的值, 1的右边界索引为0, 2的右边索引为n, 3的右边界索引即为第1个大于target的值的索引.\n左边界的思路同理, 只要保证\n[0, left)的数组值严格小于target\n[right,n)的值严格大于等于target\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left_border = LeftBorder(nums, target); if (left_border == int(nums.size()) || nums[left_border] != target) { return {-1, -1}; } int right_border = RightBoreder(nums, target) - 1; return {left_border, right_border}; } private: int RightBoreder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { // 缩小区间找第一个大于target的值 int left, right, mid; right = int(nums.size()); left = 0; while (left \u0026lt; right) // [right,n-1)的值严格大于targt // [0, left)的值严格小于等于target // 最后left==right { mid = left + ((right - left) / 2); if (nums[mid] \u0026gt; target) { right = mid; } // nums[mid] \u0026lt;= target // 因为left处于开的位置, 已知mid\u0026lt;=target, 故left = mid+1 else { left = mid + 1; // } } return left; } int LeftBorder(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left, right, mid; left = 0; right = int(nums.size()); while (left \u0026lt; right) { mid = left + (right - left) / 2; if (nums[mid] \u0026gt;= target) { right = mid; } // nums[mid] \u0026lt; target else { left = mid + 1; } } return left; } }; int main() { vector\u0026lt;int\u0026gt; nums = {5,7,7,8,8,10}; int target = 8; Solution s; vector\u0026lt;int\u0026gt;result = s.searchRange(nums,target); cout \u0026lt;\u0026lt;\u0026#34;Result for \u0026#34;\u0026lt;\u0026lt; target \u0026lt;\u0026lt; \u0026#34;: [\u0026#34; \u0026lt;\u0026lt; result[0] \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; result[1] \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-05-16T15:39:59+08:00","image":"https://Sophomoresty.github.io/Sophomoresty.io/img/lucy_1.png","permalink":"https://Sophomoresty.github.io/Sophomoresty.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95_day_1_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%BE%B9%E7%95%8C/","title":"代码随想录_day_1_二分查找边界"}]